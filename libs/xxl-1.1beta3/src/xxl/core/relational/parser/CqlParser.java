/* Generated By:JavaCC: Do not edit this line. CqlParser.java */
package xxl.core.relational.parser;

import java.io.DataInputStream;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.List;

import xxl.core.cursors.Cursors;
import xxl.core.functions.Function;
import xxl.core.functions.Identity;
import xxl.core.relational.query.Node;
import xxl.core.relational.query.Nodes;
import xxl.core.relational.query.expressions.Aggregates;
import xxl.core.relational.query.expressions.Columns;
import xxl.core.relational.query.expressions.Constants;
import xxl.core.relational.query.expressions.Expressions;
import xxl.core.relational.query.expressions.Functions;
import xxl.core.relational.query.expressions.RenamedColumns;
import xxl.core.relational.query.expressions.Tables;
import xxl.core.relational.query.operators.Aggregations;
import xxl.core.relational.query.operators.Distincts;
import xxl.core.relational.query.operators.Enumerations;
import xxl.core.relational.query.operators.Excepts;
import xxl.core.relational.query.operators.Intersects;
import xxl.core.relational.query.operators.Joins;
import xxl.core.relational.query.operators.Mappings;
import xxl.core.relational.query.operators.Operators;
import xxl.core.relational.query.operators.Renamings;
import xxl.core.relational.query.operators.Selections;
import xxl.core.relational.query.operators.Streams;
import xxl.core.relational.query.operators.Unions;
import xxl.core.relational.query.operators.Windows;
import xxl.core.relational.query.predicates.Comparisons;
import xxl.core.relational.query.predicates.LogicalOperations;

/**
 * This class provides a parser for CQL. The parser is defined by a JavaCC
 * grammar which rules are shown in the documentation of the parser's methods.
 */
public class CqlParser implements CqlParserConstants {

  /**
   * The table factory is internally used to map table references to logical
   * constructs representing the tables of a relational database. By setting
   * system-dependent table factories the CQL parser can be easily adapted to
   * deal with different database implementations without changing the code of
   * the parser.
   */
  protected Function<Node, Node> tableFactory = new Identity<Node>();

  /**
   * Returns the table factory that is internally used to map table references
   * to logical constructs representing the tables of a relational database.
   *
   * @return the table factory that is internally used to map table references
   *         to logical constructs representing the tables of a relational
   *         database.
   */
  public Function<Node, Node> getTableFactory() {
    return tableFactory;
  }

  /**
   * Sets the table factory that is internally used to map table references
   * to logical constructs representing the tables of a relational database to
   * the given one.
   *
   * @param tableFactory the table factory that should be internally used to
   *         map table references to logical constructs representing the tables
   *         of a relational database.
   */
  public void setTableFactory(Function<Node, Node> tableFactory) {
    this.tableFactory = tableFactory;
  }

  /**
   * A simple main method that can be used to parse the queries conatined by a
   * specified file. When no file is specified or the specified file cannot be
   * found, the parser reads queries form the standard input (console).
   *
   * @param args a String array holding the name of the file containing the
   *        queries to be parsed. When no file is specified or the specified
   *        file cannot be found, the parser reads queries form the standard
   *        input (console).
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  public static void main(String[] args) throws ParseException {
    CqlParser parser;

    if (args.length < 1) {
      System.out.println("Reading from stdin (type EXIT; to finish).");
      parser = new CqlParser(System.in);
    }
    else {
      System.out.println("Reading from file " + args[0] + ".");
      try {
        parser = new CqlParser(new DataInputStream(new FileInputStream(args[0])));
      }
      catch (FileNotFoundException fnfe) {
        System.out.println("File " + args[0] + " not found. Reading from stdin (type EXIT; to finish).");
        parser = new CqlParser(System.in);
      }
    }

    int line = 1;
    while (parser.CqlStatement() != null)
      System.out.println("Syntax of request #" + line++ + " is correct.");
    System.out.println("Parse Successful");
  }

  /**
   * The basic datatypes of the parser.
   *
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public void BasicDataTypeDeclaration() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_CHAR:
    case K_FLOAT:
    case K_INTEGER:
    case K_NATURAL:
    case K_NUMBER:
    case K_REAL:
    case K_VARCHAR2:
    case K_VARCHAR:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case K_CHAR:
        jj_consume_token(K_CHAR);
        break;
      case K_VARCHAR:
        jj_consume_token(K_VARCHAR);
        break;
      case K_VARCHAR2:
        jj_consume_token(K_VARCHAR2);
        break;
      case K_INTEGER:
        jj_consume_token(K_INTEGER);
        break;
      case K_NUMBER:
        jj_consume_token(K_NUMBER);
        break;
      case K_NATURAL:
        jj_consume_token(K_NATURAL);
        break;
      case K_REAL:
        jj_consume_token(K_REAL);
        break;
      case K_FLOAT:
        jj_consume_token(K_FLOAT);
        break;
      default:
        jj_la1[0] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 125:
        jj_consume_token(125);
        jj_consume_token(S_NUMBER);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 126:
          jj_consume_token(126);
          jj_consume_token(S_NUMBER);
          break;
        default:
          jj_la1[1] = jj_gen;
          ;
        }
        jj_consume_token(127);
        break;
      default:
        jj_la1[2] = jj_gen;
        ;
      }
      break;
    case K_DATE:
      jj_consume_token(K_DATE);
      break;
    case K_BINARY_INTEGER:
      jj_consume_token(K_BINARY_INTEGER);
      break;
    case K_BOOLEAN:
      jj_consume_token(K_BOOLEAN);
      break;
    default:
      jj_la1[3] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  /**
   * ---------------- Code Section starts here ----------------------
   */

  /**
   * This method represents the rule
   * <pre>
   * CqlStatements ::= ( CqlStatement )+
   * </pre>
   *
   * @return a list holding the parsed CQL statements.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public List<Node> CqlStatements() throws ParseException {
    ArrayList<Node> cqlStatements = new ArrayList<Node>();
    Node cqlStatement;
    label_1:
    while (true) {
      cqlStatement = CqlStatement();
      cqlStatements.add(cqlStatement);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case K_COMMIT:
      case K_DELETE:
      case K_DSTREAM:
      case K_EXIT:
      case K_INSERT:
      case K_ISTREAM:
      case K_LOCK:
      case K_QUIT:
      case K_ROLLBACK:
      case K_RSTREAM:
      case K_SELECT:
      case K_SET:
      case K_UPDATE:
        ;
        break;
      default:
        jj_la1[4] = jj_gen;
        break label_1;
      }
    }
    {if (true) return cqlStatements;}
    throw new Error("Missing return statement in function");
  }

  /**
   * This method represents the rule
   * <pre>
   * CqlStatement ::= CommitStatement
   *                | DeleteStatement
   *                | InsertStatement
   *                | LockTableStatement
   *                | RollbackStatement
   *                | QueryStatement
   *                | SetTransactionStatement
   *                | ( EXIT | QUIT ) ;
   * </pre>
   *
   * @return the parsed CQL statement.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public Node CqlStatement() throws ParseException {
    Node cqlStatement = null;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_COMMIT:
      cqlStatement = CommitStatement();
      break;
    case K_DELETE:
      cqlStatement = DeleteStatement();
      break;
    case K_INSERT:
      cqlStatement = InsertStatement();
      break;
    case K_LOCK:
      cqlStatement = LockTableStatement();
      break;
    case K_ROLLBACK:
      cqlStatement = RollbackStatement();
      break;
    case K_DSTREAM:
    case K_ISTREAM:
    case K_RSTREAM:
    case K_SELECT:
      cqlStatement = QueryStatement();
      break;
    case K_SET:
      cqlStatement = SetTransactionStatement();
      break;
    case K_UPDATE:
      cqlStatement = UpdateStatement();
      break;
    case K_EXIT:
    case K_QUIT:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case K_EXIT:
        jj_consume_token(K_EXIT);
        break;
      case K_QUIT:
        jj_consume_token(K_QUIT);
        break;
      default:
        jj_la1[5] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      jj_consume_token(128);
      break;
    default:
      jj_la1[6] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return cqlStatement;}
    throw new Error("Missing return statement in function");
  }

  /**
   * This method represents the rule
   * <pre>
   * CommitStatement ::= COMMIT [ WORK ] [ COMMENT &lt;comment&gt; ] ;
   * </pre>
   *
   * @return the parse COMMIT statement.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public Node CommitStatement() throws ParseException {
    jj_consume_token(K_COMMIT);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_WORK:
      jj_consume_token(K_WORK);
      break;
    default:
      jj_la1[7] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_COMMENT:
      jj_consume_token(K_COMMENT);
      jj_consume_token(S_CHAR_LITERAL);
      break;
    default:
      jj_la1[8] = jj_gen;
      ;
    }
    jj_consume_token(128);
    {if (true) throw new UnsupportedOperationException("a COMMIT statement has been parsed successfully, but COMMIT statements are not yet supported");}
    throw new Error("Missing return statement in function");
  }

  /**
   * This method represents the rule
   * <pre>
   * LockTableStatement ::= LOCK TABLE TableReference ( , TableReference )* IN LockMode MODE [ NOWAIT ];
   * </pre>
   *
   * @return the parsed LOCK TABLE statement.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public Node LockTableStatement() throws ParseException {
    jj_consume_token(K_LOCK);
    jj_consume_token(K_TABLE);
    TableReference();
    label_2:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 126:
        ;
        break;
      default:
        jj_la1[9] = jj_gen;
        break label_2;
      }
      jj_consume_token(126);
      TableReference();
    }
    jj_consume_token(K_IN);
    LockMode();
    jj_consume_token(K_MODE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_NOWAIT:
      jj_consume_token(K_NOWAIT);
      break;
    default:
      jj_la1[10] = jj_gen;
      ;
    }
    jj_consume_token(128);
    {if (true) throw new UnsupportedOperationException("a LOCK TABLE statement has been parsed successfully, but LOCK TABLE statements are not yet supported");}
    throw new Error("Missing return statement in function");
  }

  /**
   * This method represents the rule
   * <pre>
   * RollbackStatement ::= ROLLBACK [ WORK ] [ COMMENT &lt;comment&gt; ] ;
   * </pre>
   *
   * @return the parsed ROLLBACK statement.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public Node RollbackStatement() throws ParseException {
    jj_consume_token(K_ROLLBACK);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_WORK:
      jj_consume_token(K_WORK);
      break;
    default:
      jj_la1[11] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_COMMENT:
      jj_consume_token(K_COMMENT);
      jj_consume_token(S_CHAR_LITERAL);
      break;
    default:
      jj_la1[12] = jj_gen;
      ;
    }
    jj_consume_token(128);
    {if (true) throw new UnsupportedOperationException("a ROLLBACK statement has been parsed successfully, but ROLLBACK statements are not yet supported");}
    throw new Error("Missing return statement in function");
  }

  /**
   * This method represents the rule
   * <pre>
   * SetTransactionStatement ::= SET TRANSACTION READ ( ONLY | WRITE )
   * </pre>
   *
   * @return the parsed SET TRANSACTION statement.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public Node SetTransactionStatement() throws ParseException {
    jj_consume_token(K_SET);
    jj_consume_token(K_TRANSACTION);
    jj_consume_token(K_READ);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_ONLY:
      jj_consume_token(K_ONLY);
      break;
    case K_WRITE:
      jj_consume_token(K_WRITE);
      break;
    default:
      jj_la1[13] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(128);
    {if (true) throw new UnsupportedOperationException("a SET TRANSACTION statement has been parsed successfully, but SET TRANSACTION statements are not yet supported");}
    throw new Error("Missing return statement in function");
  }

  /**
   * This method represents the rule
   * <pre>
   * LockMode ::= ROW ( SHARE | EXCLUSIVE )
   *            | SHARE [ UPDATE | ROW EXCLUSIVE ]
   *            | EXCLUSIVE
   * </pre>
   *
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public void LockMode() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_ROW:
      jj_consume_token(K_ROW);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case K_SHARE:
        jj_consume_token(K_SHARE);
        break;
      case K_EXCLUSIVE:
        jj_consume_token(K_EXCLUSIVE);
        break;
      default:
        jj_la1[14] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    case K_SHARE:
      jj_consume_token(K_SHARE);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case K_ROW:
      case K_UPDATE:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case K_UPDATE:
          jj_consume_token(K_UPDATE);
          break;
        case K_ROW:
          jj_consume_token(K_ROW);
          jj_consume_token(K_EXCLUSIVE);
          break;
        default:
          jj_la1[15] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[16] = jj_gen;
        ;
      }
      break;
    case K_EXCLUSIVE:
      jj_consume_token(K_EXCLUSIVE);
      break;
    default:
      jj_la1[17] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
  }

  /**
   * This method represents the rule
   * <pre>
   * UpdateStatement ::= UPDATE TableReference SET ColumnValues [ WHERE SqlExpression ] ;
   * </pre>
   *
   * @return the parsed UPDATE statement.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public Node UpdateStatement() throws ParseException {
    jj_consume_token(K_UPDATE);
    TableReference();
    jj_consume_token(K_SET);
    ColumnValues();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_WHERE:
      jj_consume_token(K_WHERE);
      SqlExpression(new ArrayList<Node>());
      break;
    default:
      jj_la1[18] = jj_gen;
      ;
    }
    jj_consume_token(128);
    {if (true) throw new UnsupportedOperationException("an UPDATE statement has been parsed successfully, but UPDATE statements are not yet supported");}
    throw new Error("Missing return statement in function");
  }

  /**
   * This method represents the rule
   * <pre>
   * ColumnValues ::= TableColumn = UpdatedValue ( , TableColumn = UpdatedValue )*
   * </pre>
   *
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public void ColumnValues() throws ParseException {
    TableColumn();
    jj_consume_token(129);
    UpdatedValue();
    label_3:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 126:
        ;
        break;
      default:
        jj_la1[19] = jj_gen;
        break label_3;
      }
      jj_consume_token(126);
      TableColumn();
      jj_consume_token(129);
      UpdatedValue();
    }
  }

  /**
   * This method represents the rule
   * <pre>
   * UpdatedValue ::= "(" SelectStatement ")"
   *                | SqlExpression
   *                | PreparedCol
   * </pre>
   *
   * <p>An updated value can be a subquery or an expression.</p>
   *
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public void UpdatedValue() throws ParseException {
    if (jj_2_1(2147483647)) {
      jj_consume_token(125);
      SelectStatement();
      jj_consume_token(127);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case K_CASE:
      case K_COUNT:
      case K_EXISTS:
      case K_MAX:
      case K_MIN:
      case K_NOT:
      case K_NULL:
      case K_PRIOR:
      case K_STDDEV_POP:
      case K_STDDEV_SAMP:
      case K_SUM:
      case K_VAR_POP:
      case K_VAR_SAMP:
      case S_NUMBER:
      case S_IDENTIFIER:
      case S_BIND:
      case S_CHAR_LITERAL:
      case S_QUOTED_IDENTIFIER:
      case 125:
      case 138:
      case 139:
      case 148:
        SqlExpression(new ArrayList<Node>());
        break;
      case 144:
        PreparedCol();
        break;
      default:
        jj_la1[20] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
  }

  /**
   * This method represents the rule
   * <pre>
   * InsertStatement ::= INSERT INTO TableReference [ "(" TableColumnList ")" ]  ( ValueSpec | SelectStatement ) ;
   * ValueSpec ::= VALUES "(" SqlExpressionList ")"
   * </pre>
   *
   * <b>13/02/06 T. Riemenschneider</b> Replaced former definition<br>
   * <pre>InsertStatement ::= INSERT INTO TableReference [ "(" TableColumn ( "," TableColumn )* ")" ]  ( ValueSpec | SelectStatement ) ;</pre></p>
   *
   * @return the parsed INSERT statement.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public Node InsertStatement() throws ParseException {
    ArrayList<Node> tableColumnList = new ArrayList<Node>();
    jj_consume_token(K_INSERT);
    jj_consume_token(K_INTO);
    TableReference();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 125:
      jj_consume_token(125);
      TableColumnList(tableColumnList);
      jj_consume_token(127);
      break;
    default:
      jj_la1[21] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_VALUES:
      jj_consume_token(K_VALUES);
      jj_consume_token(125);
      SqlExpressionList(new ArrayList<Node>());
      jj_consume_token(127);
      break;
    case K_SELECT:
      SelectStatement();
      break;
    default:
      jj_la1[22] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(128);
    {if (true) throw new UnsupportedOperationException("an INSERT statement has been parsed successfully, but INSERT statements are not yet supported");}
    throw new Error("Missing return statement in function");
  }

  /**
   * This method represents the rule
   * <pre>
   * DeleteStatement ::= DELETE [ FROM ] TableReference [ WHERE SqlExpression ] ;
   * </pre>
   *
   * @return the parsed DELETE statement.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public Node DeleteStatement() throws ParseException {
    jj_consume_token(K_DELETE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_FROM:
      jj_consume_token(K_FROM);
      break;
    default:
      jj_la1[23] = jj_gen;
      ;
    }
    TableReference();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_WHERE:
      jj_consume_token(K_WHERE);
      SqlExpression(new ArrayList<Node>());
      break;
    default:
      jj_la1[24] = jj_gen;
      ;
    }
    jj_consume_token(128);
    {if (true) throw new UnsupportedOperationException("a DELETE statement has been parsed successfully, but DELETE statements are not yet supported");}
    throw new Error("Missing return statement in function");
  }

  /**
   * This method represents the rule
   * <pre>
   * QueryStatement ::= SelectStatement ;
   *                  | StreamClause "(" SelectWithoutOrder ")" ;
   * </pre>
   *
   * @return the parsed CQL query statement.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public Node QueryStatement() throws ParseException {
    Streams.Type type;
    Node queryStatement;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_SELECT:
      queryStatement = SelectStatement();
      jj_consume_token(128);
      break;
    case K_DSTREAM:
    case K_ISTREAM:
    case K_RSTREAM:
      type = StreamClause();
      jj_consume_token(125);
      queryStatement = SelectWithoutOrder();
      jj_consume_token(127);
      jj_consume_token(128);
      queryStatement = Streams.newStream(queryStatement, type);
      break;
    default:
      jj_la1[25] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return queryStatement;}
    throw new Error("Missing return statement in function");
  }

  /**
   * This method represents the rule
   * <pre>
   * StreamClause ::= ISTREAM
   *                | DSTREAM
   *                | RSTREAM
   * </pre>
   *
   * @return the parsed stream type.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public Streams.Type StreamClause() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_ISTREAM:
      jj_consume_token(K_ISTREAM);
      {if (true) return Streams.Type.INSERT;}
      break;
    case K_DSTREAM:
      jj_consume_token(K_DSTREAM);
      {if (true) return Streams.Type.DELETE;}
      break;
    case K_RSTREAM:
      jj_consume_token(K_RSTREAM);
      {if (true) return Streams.Type.RELATION;}
      break;
    default:
      jj_la1[26] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  /**
   * This method represents the rule
   * <pre>
   * TableColumn ::= OracleObjectName [ . OracleObjectName [ . OracleObjectName ] ]
   * </pre>
   *
   * <p>The table column can be something like
   * <tt>schema.table.column</tt>.</p>
   *
   * @return the parsed table column.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public Node TableColumn() throws ParseException {
    ArrayList<String> tableColumn = new ArrayList<String>(3);
    String oracleObjectName;
    oracleObjectName = OracleObjectName();
    tableColumn.add(oracleObjectName);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 130:
      jj_consume_token(130);
      oracleObjectName = OracleObjectName();
      tableColumn.add(oracleObjectName);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 130:
        jj_consume_token(130);
        oracleObjectName = OracleObjectName();
        tableColumn.add(oracleObjectName);
        break;
      default:
        jj_la1[27] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[28] = jj_gen;
      ;
    }
    {if (true) return tableColumn.size() == 3 ? Columns.newColumn(tableColumn.get(0), tableColumn.get(1), tableColumn.get(2)) : tableColumn.size() == 2 ? Columns.newColumn(tableColumn.get(0), tableColumn.get(1)) : Columns.newColumn(tableColumn.get(0));}
    throw new Error("Missing return statement in function");
  }

  /**
   * This method represents the rule
   * <pre>
   * TableColumnList ::= TableColumn ( , TableColumn )*
   * </pre>
   *
   * <p><b>VERSION INFO:</b><br>
   * <b>13/02/06 T. Riemenschneider</b> Added table column lists</p>
   *
   * @param tableColumnList a list used for collecting the table columns.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public void TableColumnList(List<Node> tableColumnList) throws ParseException {
    Node tableColumn;
    tableColumn = TableColumn();
    tableColumnList.add(tableColumn);
    label_4:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 126:
        ;
        break;
      default:
        jj_la1[29] = jj_gen;
        break label_4;
      }
      jj_consume_token(126);
      tableColumn = TableColumn();
      tableColumnList.add(tableColumn);
    }
  }

  /**
   * This method represents the rule
   * <pre>
   * OracleObjectName ::= &lt;S_IDENTIFIER&gt;
   *                    | &lt;S_QUOTED_IDENTIFIER&gt;
   * </pre>
   *
   * @return the parsed Oracle object name.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public String OracleObjectName() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case S_IDENTIFIER:
      jj_consume_token(S_IDENTIFIER);
      break;
    case S_QUOTED_IDENTIFIER:
      jj_consume_token(S_QUOTED_IDENTIFIER);
      break;
    default:
      jj_la1[30] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return token.image;}
    throw new Error("Missing return statement in function");
  }

  /**
   * This method represents the rule
   * <pre>
   * RelOp ::= =
   *         | !=
   *         | #
   *         | &lt;&gt;
   *         | &gt;
   *         | &gt;=
   *         | &lt;
   *         | &lt;=
   * </pre>
   *
   * @return the parsed relational operation.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public Comparisons.Type Relop() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 129:
      jj_consume_token(129);
      {if (true) return Comparisons.Type.EQUAL;}
      break;
    case 131:
      jj_consume_token(131);
      {if (true) return Comparisons.Type.UNEQUAL;}
      break;
    case 132:
      jj_consume_token(132);
      {if (true) return Comparisons.Type.UNEQUAL;}
      break;
    case 133:
      jj_consume_token(133);
      {if (true) return Comparisons.Type.UNEQUAL;}
      break;
    case 134:
      jj_consume_token(134);
      {if (true) return Comparisons.Type.GREATER;}
      break;
    case 135:
      jj_consume_token(135);
      {if (true) return Comparisons.Type.GREATER_EQUAL;}
      break;
    case 136:
      jj_consume_token(136);
      {if (true) return Comparisons.Type.LESS;}
      break;
    case 137:
      jj_consume_token(137);
      {if (true) return Comparisons.Type.LESS_EQUAL;}
      break;
    default:
      jj_la1[31] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  /**
   * This method represents the rule
   * <pre>
   * TableReference ::= OracleObjectName [ . OracleObjectName ]
   * </pre>
   *
   * @return the parsed table reference.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public Node TableReference() throws ParseException {
    ArrayList<String> tableReference = new ArrayList<String>(2);
    String oracleObjectName;
    oracleObjectName = OracleObjectName();
    tableReference.add(oracleObjectName);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 130:
      jj_consume_token(130);
      oracleObjectName = OracleObjectName();
      tableReference.add(oracleObjectName);
      break;
    default:
      jj_la1[32] = jj_gen;
      ;
    }
    {if (true) return tableReference.size() == 2 ? Tables.newTable(tableReference.get(0), tableReference.get(1)) : Tables.newTable(tableReference.get(0));}
    throw new Error("Missing return statement in function");
  }

  /**
   * This method represents the rule
   * <pre>
   * NumOrID ::= &lt;S_IDENTIFIER&gt;
   *           | [ + | - ] &lt;S_NUMBER&gt;
   * </pre>
   *
   * @return the parsed number or ID.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public String NumOrID() throws ParseException {
    String sign = "";
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case S_IDENTIFIER:
      jj_consume_token(S_IDENTIFIER);
      break;
    case S_NUMBER:
    case 138:
    case 139:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 138:
      case 139:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 138:
          jj_consume_token(138);
          break;
        case 139:
          jj_consume_token(139);
          break;
        default:
          jj_la1[33] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[34] = jj_gen;
        ;
      }
      sign = token.image;
      jj_consume_token(S_NUMBER);
      break;
    default:
      jj_la1[35] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return sign + token.image;}
    throw new Error("Missing return statement in function");
  }

  /**
   * This method represents the rule
   * <pre>
   * SelectStatement ::= SelectWithoutOrder [ OrderByClause ] [ ForUpdateClasue ]
   * </pre>
   *
   * @return the parsed SELECT statement.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public Node SelectStatement() throws ParseException {
    Node selectStatement;
    selectStatement = SelectWithoutOrder();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_ORDER:
      OrderByClause();
      break;
    default:
      jj_la1[36] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_FOR:
      ForUpdateClause();
      break;
    default:
      jj_la1[37] = jj_gen;
      ;
    }
    {if (true) return selectStatement;}
    throw new Error("Missing return statement in function");
  }

  /**
   * This method represents the rule
   * <pre>
   * SelectWithoutOrder ::= SELECT [ ALL | DISTINCT ] SelectList FromClause [ WhereClause ] [ ConnectClause ] [ GroupByClause ] [ SetClause ]
   * </pre>
   *
   * @return the parsed SELECT statement (without ORDER BY clause).
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public Node SelectWithoutOrder() throws ParseException {
    Node selectWithoutOrder;
    List<Node> mappings = new ArrayList<Node>();
    List<Node> aggregates = new ArrayList<Node>() {
      @Override
      public int indexOf(Object node) {
        if (node == null) {
          for (int i = 0; i < size(); i++)
            if (get(i) == null)
              return i;
        }
        else {
          if (!(node instanceof Node))
            return -1;
          for (int i = 0; i < size(); i++)
            if (((Node)node).checkAllSignatures(get(i)))
              return i;
        }
        return -1;
      }

      @Override
      public int lastIndexOf(Object node) {
        if (node == null) {
          for (int i = size()-1; i >= 0; i--)
            if (get(i) == null)
              return i;
        }
        else {
          if (!(node instanceof Node))
            return -1;
          for (int i = size()-1; i >= 0; i--)
            if (((Node)node).checkAllSignatures(get(i)))
              return i;
        }
        return -1;
      }

      @Override
      public boolean remove(Object node) {
        if (node == null) {
          for (int index = 0; index < size(); index++)
            if (get(index) == null) {
              remove(index);
              return true;
            }
        }
        else {
          if (!(node instanceof Node))
              return false;
          for (int index = 0; index < size(); index++)
            if (((Node)node).checkAllSignatures(get(index))) {
              remove(index);
              return true;
            }
        }
        return false;
      }
    };
    List<Node> groupColumns = new ArrayList<Node>();
    boolean distinct = false;
    boolean selectAll = false;
    jj_consume_token(K_SELECT);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_ALL:
    case K_DISTINCT:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case K_ALL:
        jj_consume_token(K_ALL);
        break;
      case K_DISTINCT:
        jj_consume_token(K_DISTINCT);
        distinct = true;
        break;
      default:
        jj_la1[38] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[39] = jj_gen;
      ;
    }
    selectAll = SelectList(mappings, aggregates);
    selectWithoutOrder = FromClause(aggregates);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_WHERE:
      selectWithoutOrder = WhereClause(selectWithoutOrder, aggregates);
      break;
    default:
      jj_la1[40] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_CONNECT:
    case K_START:
      ConnectClause(aggregates);
      break;
    default:
      jj_la1[41] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_GROUP:
      groupColumns = GroupByClause(aggregates);
      break;
    default:
      jj_la1[42] = jj_gen;
      ;
    }
    int i = groupColumns.size() + 1;
    int actualNumberOfParents;
    for (Node aggregate : aggregates) {
      if ((actualNumberOfParents = aggregate.getActualNumberOfParents()) > 0)
        for (Node parent : Cursors.toArray(aggregate.getParents(), new Node[actualNumberOfParents]))
          parent.replaceChild(aggregate, Columns.newColumn(0, i));
      i++;
    }
    i = 0;
    for (Node mapping : mappings) {
      if (Nodes.getType(mapping) == Expressions.NODE_TYPE && Expressions.getType(mapping) == Aggregates.EXPRESSION_TYPE)
        mappings.set(i, Columns.newColumn(0, groupColumns.size() + aggregates.indexOf(mapping) + 1));
      i++;
    }
    if (!selectAll) {
      if (aggregates.size() > 0)
        selectWithoutOrder = Aggregations.newAggregation(selectWithoutOrder, groupColumns.iterator(), aggregates.iterator());
      selectWithoutOrder = Mappings.newMapping(selectWithoutOrder, mappings.iterator());
    }
    if (distinct)
      selectWithoutOrder = Distincts.newDistinct(selectWithoutOrder);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_EXCEPT:
    case K_INTERSECT:
    case K_MINUS:
    case K_UNION:
      selectWithoutOrder = SetClause(selectWithoutOrder);
      break;
    default:
      jj_la1[43] = jj_gen;
      ;
    }
    {if (true) return selectWithoutOrder;}
    throw new Error("Missing return statement in function");
  }

  /**
   * Checks for whatever follows SELECT
   *
   * This method represents the rule
   * <pre>
   * SelectList ::= *
   *              | SelectItem ( , SelectItem )*
   * </pre>
   *
   * <p><b>VERSION INFO:</b><br>
   * <b>18/10/01 PY. Gibello</b> Removed "COUNT(*)" from here<br>
   * COUNT is an aggregate, like AVG...</p>
   *
   * @param mappings a list used for collecting the selected expressions.
   * @param aggregates a list used for collecting the aggregate calls.
   * @return <code>true</code> if all columns are selected, otherwise
   *         <code>false</code>.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public boolean SelectList(List<Node> mappings, List<Node> aggregates) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 140:
      jj_consume_token(140);
      {if (true) return true;}
      break;
    case K_CASE:
    case K_COUNT:
    case K_MAX:
    case K_MIN:
    case K_NULL:
    case K_STDDEV_POP:
    case K_STDDEV_SAMP:
    case K_SUM:
    case K_VAR_POP:
    case K_VAR_SAMP:
    case S_NUMBER:
    case S_IDENTIFIER:
    case S_BIND:
    case S_CHAR_LITERAL:
    case S_QUOTED_IDENTIFIER:
    case 125:
    case 138:
    case 139:
    case 148:
      SelectItem(mappings, aggregates);
      label_5:
      while (true) {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 126:
          ;
          break;
        default:
          jj_la1[44] = jj_gen;
          break label_5;
        }
        jj_consume_token(126);
        SelectItem(mappings, aggregates);
      }
      {if (true) return false;}
      break;
    default:
      jj_la1[45] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  /**
   * This method represents the rule
   * <pre>
   * SelectItem ::= SelectStar
   *              | SqlSimpleExpression [ SelectAlias ]
   * </pre>
   *
   * <p><b>VERSION INFO:</b><br>
   * <b>01/07/00 PY. Gibello</b> Added LOOKAHEAD(3) before COUNT<br>
   * Due to a fix in AggregateFunc (COUNT added) that made the grammar
   * ambiguous<br>
   * <b>18/10/01 PY. Gibello</b> Removed "COUNT(*)" from here (see aggregate
   * funcs)</p>
   *
   * @param mappings a list used for collecting the selected expressions.
   * @param aggregates a list used for collecting the aggregate calls.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public void SelectItem(List<Node> mappings, List<Node> aggregates) throws ParseException {
    Node mapping;
    String renaming;
    if (jj_2_2(2147483647)) {
      mapping = SelectStar();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case K_CASE:
      case K_COUNT:
      case K_MAX:
      case K_MIN:
      case K_NULL:
      case K_STDDEV_POP:
      case K_STDDEV_SAMP:
      case K_SUM:
      case K_VAR_POP:
      case K_VAR_SAMP:
      case S_NUMBER:
      case S_IDENTIFIER:
      case S_BIND:
      case S_CHAR_LITERAL:
      case S_QUOTED_IDENTIFIER:
      case 125:
      case 138:
      case 139:
      case 148:
        mapping = SqlSimpleExpression(aggregates);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case K_AS:
        case S_IDENTIFIER:
          renaming = Alias();
          mapping = RenamedColumns.newRenamedColumn(mapping, renaming);
          break;
        default:
          jj_la1[46] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[47] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    mappings.add(mapping);
  }

  /**
   * This method represents the rule
   * <pre>
   * Alias ::= [ AS ] <S_IDENTIFIER>
   * </pre>
   *
   * <p><b>VERSION INFO:</b><br>
   * <b>07/11/05 T. Riemenschneider</b> Replaced former definition<br>
   * <pre>SelectAlias ::= [ AS ] ( <S_IDENTIFIER> )+</pre></p>
   *
   * @return the parsed alias.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public String Alias() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_AS:
      jj_consume_token(K_AS);
      break;
    default:
      jj_la1[48] = jj_gen;
      ;
    }
    jj_consume_token(S_IDENTIFIER);
    {if (true) return token.image;}
    throw new Error("Missing return statement in function");
  }

  /**
   * This method represents the rule
   * <pre>
   * SelectStar ::= OracleObjectName ".*"
   *              | OracleObjectName "." OracleObjectName ".*"
   * </pre>
   *
   * <p>The SELECT star expression can be something like
   * <tt>table.*</tt> or <tt>schema.table.*</tt>.</p>
   *
   * @return the parsed star expression.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public Node SelectStar() throws ParseException {
    if (jj_2_3(2)) {
      OracleObjectName();
      jj_consume_token(141);
    } else if (jj_2_4(4)) {
      OracleObjectName();
      jj_consume_token(130);
      OracleObjectName();
      jj_consume_token(141);
    } else {
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) throw new UnsupportedOperationException("a table column specified by a star (*) has been parsed successfully, but the use of table columns specified b a star (*) is not yet supported");}
    throw new Error("Missing return statement in function");
  }

  /**
   * This method represents the rule
   * <pre>
   * FromClause ::= FROM FromItem ( , FromItem )*
   * </pre>
   *
   * @param aggregates a list used for collecting the aggregate calls.
   * @return the parsed FROM clause.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public Node FromClause(List<Node> aggregates) throws ParseException {
    Node fromClause;
    Node fromItem;
    jj_consume_token(K_FROM);
    fromClause = FromItem(aggregates);
    label_6:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 126:
        ;
        break;
      default:
        jj_la1[49] = jj_gen;
        break label_6;
      }
      jj_consume_token(126);
      fromItem = FromItem(aggregates);
      fromClause = Joins.newCrossJoin(fromClause, fromItem);
    }
    {if (true) return fromClause;}
    throw new Error("Missing return statement in function");
  }

  /**
   * This method represents the rule
   * <pre>
   * FromItem ::= TableReference [ WindowClause ] [ Alias ]
   *            | "(" SubQuery ")" [ WindowClause ] Alias
   *            | JoinedTable
   * </pre>
   *
   * <p><b>VERSION INFO:</b><br>
   * <b>08/11/05 T. Riemenschneider</b> Replaced former definition<br>
   * <pre>FromItem ::= TableReference [ &lt;alias&gt; ]</pre><br>
   * <b>13/02/06 T. Riemenschneider</b> Added subqueries and joins<br>
   * <b>30/03/06 T. Riemenschneider</b> Replaced former definition<br>
   * <pre>FromItem ::= TableReference [ "[" WindowClause "]" ] [ Alias ] | "(" SubQuery ")" [ WindowClause ] Alias | JoinedTable</pre></p>
   *
   * @param aggregates a list used for collecting the aggregate calls.
   * @return the parsed FROM item.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public Node FromItem(List<Node> aggregates) throws ParseException {
    Node tableReference;
    Node fromItem;
    String renaming;
    if (jj_2_5(3)) {
      fromItem = JoinedTable(aggregates);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S_IDENTIFIER:
      case S_QUOTED_IDENTIFIER:
        tableReference = TableReference();
        fromItem = tableFactory.invoke(tableReference);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 142:
          fromItem = WindowClause(fromItem);
          break;
        default:
          jj_la1[50] = jj_gen;
          ;
        }
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case K_AS:
        case S_IDENTIFIER:
          renaming = Alias();
          fromItem = Renamings.newRenaming(fromItem, renaming);
          break;
        default:
          jj_la1[51] = jj_gen;
          ;
        }
        break;
      case 125:
        jj_consume_token(125);
        fromItem = SubQuery();
        jj_consume_token(127);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case 142:
          fromItem = WindowClause(fromItem);
          break;
        default:
          jj_la1[52] = jj_gen;
          ;
        }
        renaming = Alias();
        fromItem = Renamings.newRenaming(fromItem, renaming);
        break;
      default:
        jj_la1[53] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    {if (true) return fromItem;}
    throw new Error("Missing return statement in function");
  }

  /**
   * This method represents the rule
   * <pre>
   * WindowClause ::= "[" [ PARTITION BY TableColumnList ] ( RANGE ( TimeExpression | UNBOUNDED ) | NOW | ROWS ( &lt;S_NUMBER&gt; | UNBOUNDED ) ) "]" [ AS ( RELATION | STREAM ) ]
   * </pre>
   *
   * <p><b>VERSION INFO:</b><br>
   * <b>13/02/06 T. Riemenschneider</b> Replaced former definition<br>
   * <pre>WindowClause ::= [ PARTITION BY PartitionList ] ( RANGE ( TimeExpression | UNBOUNDED ) | NOW | ROWS ( &lt;S_NUMBER&gt; | UNBOUNDED ) )</pre><br>
   * <b>21/02/06 T. Riemenschneider</b> Replaced former definition<br>
   * <pre>WindowClause ::= [ PARTITION BY TableColumnList ] ( RANGE ( TimeExpression | UNBOUNDED ) | NOW | ROWS ( &lt;S_NUMBER&gt; | UNBOUNDED ) )</pre><br>
   * <b>21/02/06 T. Riemenschneider</b> Replaced former definition<br>
   * <pre>WindowClause ::= [ PARTITION BY TableColumnList ] ( RANGE ( TimeExpression | UNBOUNDED ) | NOW | ROWS ( &lt;S_NUMBER&gt; | UNBOUNDED ) ) [ AS ( RELATION | STREAM ) ]</pre></p>
   *
   * @param fromItem the from item the window clause to be parsed belongs to.
   * @return the parsed window clause.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public Node WindowClause(Node fromItem) throws ParseException {
    Windows.Type type;
    long size;
    Operators.Mode mode = Operators.Mode.PASSIVE;
    ArrayList<Node> tableColumnList = new ArrayList<Node>();
    jj_consume_token(142);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_PARTITION:
      jj_consume_token(K_PARTITION);
      jj_consume_token(K_BY);
      TableColumnList(tableColumnList);
      break;
    default:
      jj_la1[54] = jj_gen;
      ;
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_NOW:
    case K_RANGE:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case K_RANGE:
        jj_consume_token(K_RANGE);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S_NUMBER:
          size = TimeExpression();
          break;
        case K_UNBOUNDED:
          jj_consume_token(K_UNBOUNDED);
          size = Windows.UNBOUNDED;
          break;
        default:
          jj_la1[55] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      case K_NOW:
        jj_consume_token(K_NOW);
        size = 0;
        break;
      default:
        jj_la1[56] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      type = Windows.Type.TIME_BASED;
      break;
    case K_ROWS:
      jj_consume_token(K_ROWS);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case S_NUMBER:
        jj_consume_token(S_NUMBER);
        size = Long.parseLong(token.image);
        break;
      case K_UNBOUNDED:
        jj_consume_token(K_UNBOUNDED);
        size = Windows.UNBOUNDED;
        break;
      default:
        jj_la1[57] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      type = Windows.Type.TUPLE_BASED;
      break;
    default:
      jj_la1[58] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(143);
    if (jj_2_6(2)) {
      jj_consume_token(K_AS);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case K_RELATION:
        jj_consume_token(K_RELATION);
        break;
      case K_STREAM:
        jj_consume_token(K_STREAM);
        mode = Operators.Mode.ACTIVE;
        break;
      default:
        jj_la1[59] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    } else {
      ;
    }
    {if (true) return Windows.newWindow(fromItem, type, size, mode, tableColumnList.iterator());}
    throw new Error("Missing return statement in function");
  }

  /**
   * This method represents the rule
   * <pre>
   * TimeExpression ::= &lt;S_NUMBER&gt; [ SECOND | SECONDS | MINUTE | MINUTES | HOUR | HOURS | DAY | DAYS ]
   * </pre>
   *
   * @return the parsed time expression.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public long TimeExpression() throws ParseException {
    long timeExpression;
    jj_consume_token(S_NUMBER);
    timeExpression = Long.parseLong(token.image);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_DAY:
    case K_DAYS:
    case K_HOUR:
    case K_HOURS:
    case K_MINUTE:
    case K_MINUTES:
    case K_SECOND:
    case K_SECONDS:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case K_SECOND:
      case K_SECONDS:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case K_SECOND:
          jj_consume_token(K_SECOND);
          break;
        case K_SECONDS:
          jj_consume_token(K_SECONDS);
          break;
        default:
          jj_la1[60] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        timeExpression *= 1000;
        break;
      case K_MINUTE:
      case K_MINUTES:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case K_MINUTE:
          jj_consume_token(K_MINUTE);
          break;
        case K_MINUTES:
          jj_consume_token(K_MINUTES);
          break;
        default:
          jj_la1[61] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        timeExpression *= 60000;
        break;
      case K_HOUR:
      case K_HOURS:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case K_HOUR:
          jj_consume_token(K_HOUR);
          break;
        case K_HOURS:
          jj_consume_token(K_HOURS);
          break;
        default:
          jj_la1[62] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        timeExpression *= 3600000;
        break;
      case K_DAY:
      case K_DAYS:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case K_DAY:
          jj_consume_token(K_DAY);
          break;
        case K_DAYS:
          jj_consume_token(K_DAYS);
          break;
        default:
          jj_la1[63] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        timeExpression *= 86400000;
        break;
      default:
        jj_la1[64] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[65] = jj_gen;
      ;
    }
    {if (true) return timeExpression;}
    throw new Error("Missing return statement in function");
  }

  /**
   * This method represents the rule
   * <pre>
   * JoinedTable ::= TableReference "CROSS" "JOIN" TableReference
   *               | TableReference "NATURAL" [ "INNER" | ( "LEFT" | "RIGHT" | "FULL" ) [ "OUTER" ] | "UNION" ] "JOIN" TableReference
   *               | TableReference [ "INNER" | ( "LEFT" | "RIGHT" | "FULL" ) [ "OUTER" ] | "UNION" ] "JOIN" TableReference [ "ON" SqlExpression | "USING" "(" TableColumnList ")" ]
   *               | "(" JoinedTable ")"
   * </pre>
   *
   * <p><b>VERSION INFO:</b><br>
   * <b>13/02/06 T. Riemenschneider</b> Added join syntax</p>
   *
   * @param aggregates a list used for collecting the aggregate calls.
   * @return the parsed joined table.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public Node JoinedTable(List<Node> aggregates) throws ParseException {
    Node joinedTable;
    Node tableReference;
    Joins.Type type = Joins.Type.CROSS_JOIN;
    Joins.Subtype subtype = Joins.Subtype.INNER_JOIN;
    int choice = 0;
    Node joinPredicate = null;
    ArrayList<Node> tableColumnList = new ArrayList<Node>();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case S_IDENTIFIER:
    case S_QUOTED_IDENTIFIER:
      joinedTable = TableReference();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case K_CROSS:
        jj_consume_token(K_CROSS);
        jj_consume_token(K_JOIN);
        tableReference = TableReference();
        break;
      case K_NATURAL:
        jj_consume_token(K_NATURAL);
        type = Joins.Type.NATURAL_JOIN;
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case K_FULL:
        case K_INNER:
        case K_LEFT:
        case K_RIGHT:
        case K_UNION:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case K_INNER:
            jj_consume_token(K_INNER);
            subtype = Joins.Subtype.INNER_JOIN;
            break;
          case K_FULL:
          case K_LEFT:
          case K_RIGHT:
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case K_LEFT:
              jj_consume_token(K_LEFT);
              choice = 1;
              break;
            case K_RIGHT:
              jj_consume_token(K_RIGHT);
              choice = 2;
              break;
            case K_FULL:
              jj_consume_token(K_FULL);
              choice = 3;
              break;
            default:
              jj_la1[66] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case K_OUTER:
              jj_consume_token(K_OUTER);
              break;
            default:
              jj_la1[67] = jj_gen;
              ;
            }
            subtype = Joins.Subtype.OUTER_JOIN;
            break;
          case K_UNION:
            jj_consume_token(K_UNION);
            type = Joins.Type.THETA_JOIN;
            subtype = Joins.Subtype.OUTER_JOIN;
            choice = 3;
            joinPredicate = xxl.core.relational.query.predicates.LogicalConstants.newFalse();
            break;
          default:
            jj_la1[68] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[69] = jj_gen;
          ;
        }
        jj_consume_token(K_JOIN);
        tableReference = TableReference();
        break;
      case K_FULL:
      case K_INNER:
      case K_JOIN:
      case K_LEFT:
      case K_RIGHT:
      case K_UNION:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case K_FULL:
        case K_INNER:
        case K_LEFT:
        case K_RIGHT:
        case K_UNION:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case K_INNER:
            jj_consume_token(K_INNER);
            subtype = Joins.Subtype.INNER_JOIN;
            break;
          case K_FULL:
          case K_LEFT:
          case K_RIGHT:
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case K_LEFT:
              jj_consume_token(K_LEFT);
              choice = 1;
              break;
            case K_RIGHT:
              jj_consume_token(K_RIGHT);
              choice = 2;
              break;
            case K_FULL:
              jj_consume_token(K_FULL);
              choice = 3;
              break;
            default:
              jj_la1[70] = jj_gen;
              jj_consume_token(-1);
              throw new ParseException();
            }
            switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
            case K_OUTER:
              jj_consume_token(K_OUTER);
              break;
            default:
              jj_la1[71] = jj_gen;
              ;
            }
            subtype = Joins.Subtype.OUTER_JOIN;
            break;
          case K_UNION:
            jj_consume_token(K_UNION);
            type = Joins.Type.THETA_JOIN;
            subtype = Joins.Subtype.OUTER_JOIN;
            choice = 3;
            joinPredicate = xxl.core.relational.query.predicates.LogicalConstants.newFalse();
            break;
          default:
            jj_la1[72] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[73] = jj_gen;
          ;
        }
        jj_consume_token(K_JOIN);
        tableReference = TableReference();
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case K_ON:
        case K_USING:
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case K_ON:
            jj_consume_token(K_ON);
            joinPredicate = SqlExpression(aggregates);
            type = Joins.Type.THETA_JOIN;
            break;
          case K_USING:
            jj_consume_token(K_USING);
            jj_consume_token(125);
            TableColumnList(tableColumnList);
            jj_consume_token(127);
            type = Joins.Type.EQUI_JOIN;
            break;
          default:
            jj_la1[74] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
          break;
        default:
          jj_la1[75] = jj_gen;
          ;
        }
        break;
      default:
        jj_la1[76] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      joinedTable = tableFactory.invoke(joinedTable);
      tableReference = tableFactory.invoke(tableReference);
      switch (type) {
      case EQUI_JOIN:
        switch (subtype) {
        case INNER_JOIN:
          joinedTable = Joins.newEquiJoin(joinedTable, tableReference, tableColumnList.iterator(), tableColumnList.iterator());
          break;
        case OUTER_JOIN:
          switch (choice) {
          case 1:
            joinedTable = Joins.newLeftOuterEquiJoin(joinedTable, tableReference, tableColumnList.iterator(), tableColumnList.iterator());
            break;
          case 2:
            joinedTable = Joins.newRightOuterEquiJoin(joinedTable, tableReference, tableColumnList.iterator(), tableColumnList.iterator());
            break;
          case 3:
            joinedTable = Joins.newFullOuterEquiJoin(joinedTable, tableReference, tableColumnList.iterator(), tableColumnList.iterator());
          }
          break;
        case SEMI_JOIN:
          switch (choice) {
          case 1:
            joinedTable = Joins.newLeftSemiEquiJoin(joinedTable, tableReference, tableColumnList.iterator(), tableColumnList.iterator());
            break;
          case 2:
            joinedTable = Joins.newRightSemiEquiJoin(joinedTable, tableReference, tableColumnList.iterator(), tableColumnList.iterator());
          }
        }
        break;
      case THETA_JOIN:
        switch (subtype) {
        case INNER_JOIN:
          joinedTable = Joins.newThetaJoin(joinedTable, tableReference, joinPredicate);
          break;
        case OUTER_JOIN:
          switch (choice) {
          case 1:
            joinedTable = Joins.newLeftOuterThetaJoin(joinedTable, tableReference, joinPredicate);
            break;
          case 2:
            joinedTable = Joins.newRightOuterThetaJoin(joinedTable, tableReference, joinPredicate);
            break;
          case 3:
            joinedTable = Joins.newFullOuterThetaJoin(joinedTable, tableReference, joinPredicate);
          }
          break;
        case SEMI_JOIN:
          switch (choice) {
          case 1:
            joinedTable = Joins.newLeftSemiThetaJoin(joinedTable, tableReference, joinPredicate);
            break;
          case 2:
            joinedTable = Joins.newRightSemiThetaJoin(joinedTable, tableReference, joinPredicate);
          }
        }
        break;
      default:
        joinedTable = Joins.newJoin(type, subtype, joinedTable, tableReference);
      }
      break;
    case 125:
      jj_consume_token(125);
      joinedTable = JoinedTable(aggregates);
      jj_consume_token(127);
      break;
    default:
      jj_la1[77] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return joinedTable;}
    throw new Error("Missing return statement in function");
  }

  /**
   * This method represents the rule
   * <pre>
   * WhereClause ::= WHERE SqlExpression
   * </pre>
   *
   * @param selectWithoutOrder the SELECT statement (without ORDER BY clause)
   *        the WHERE clause to be parsed belongs to.
   * @param aggregates a list used for collecting the aggregate calls.
   * @return the parsed WHERE clause.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public Node WhereClause(Node selectWithoutOrder, List<Node> aggregates) throws ParseException {
    Node sqlExpression;
    jj_consume_token(K_WHERE);
    sqlExpression = SqlExpression(aggregates);
    {if (true) return Selections.newSelection(selectWithoutOrder, sqlExpression);}
    throw new Error("Missing return statement in function");
  }

  /**
   * This method represents the rule
   * <pre>
   * ConnectClause ::= [ START WITH SqlExpression ] CONNECT BY SqlExpression [ START WITH SqlExpression ]
   * </pre>
   *
   * <p><b>NOTE:</b> The following grammar will take 2 START WITH expressions
   * which is not correct. But alright, because only valid statements will be
   * given.</p>
   *
   * @param aggregates a list used for collecting the aggregate calls.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public void ConnectClause(List<Node> aggregates) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_START:
      jj_consume_token(K_START);
      jj_consume_token(K_WITH);
      SqlExpression(aggregates);
      break;
    default:
      jj_la1[78] = jj_gen;
      ;
    }
    jj_consume_token(K_CONNECT);
    jj_consume_token(K_BY);
    SqlExpression(aggregates);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_START:
      jj_consume_token(K_START);
      jj_consume_token(K_WITH);
      SqlExpression(aggregates);
      break;
    default:
      jj_la1[79] = jj_gen;
      ;
    }
    {if (true) throw new UnsupportedOperationException("a CONNECT clause has been parsed successfully, but CONNECT clauses are not yet supported");}
  }

  /**
   * This method represents the rule
   * <pre>
   * GroupByClause ::= GROUP BY SqlExpressionList [ HAVING SqlExpression ]
   * </pre>
   *
   * @param aggregates a list used for collecting the aggregate calls.
   * @return the parsed GROUP BY clause.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public List<Node> GroupByClause(List<Node> aggregates) throws ParseException {
    List<Node> sqlExpressionList;
    jj_consume_token(K_GROUP);
    jj_consume_token(K_BY);
    sqlExpressionList = SqlExpressionList(aggregates);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_HAVING:
      jj_consume_token(K_HAVING);
      SqlExpression(aggregates);
      {if (true) throw new UnsupportedOperationException("a GROUP BY clause with HAVING extension has been parsed successfully, but HAVING extension are not yet supported");}
      break;
    default:
      jj_la1[80] = jj_gen;
      ;
    }
    {if (true) return sqlExpressionList;}
    throw new Error("Missing return statement in function");
  }

  /**
   * This method represents the rule
   * <pre>
   * SetClause ::= UNION [ ALL ] Query
   *             | INTERSECT Query
   *             | MINUS Query
   * Query ::= SelectWithoutOrder | ( SelectWithoutOrder )
   * </pre>
   *
   * @param selectWithoutOrder the SELECT statement (without ORDER BY clause)
   *        the set clause to be parsed belongs to.
   * @return th parsed set clause.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public Node SetClause(Node selectWithoutOrder) throws ParseException {
    Node setClause = selectWithoutOrder;
    int choice;
    boolean distinct = true;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_UNION:
      jj_consume_token(K_UNION);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case K_ALL:
        jj_consume_token(K_ALL);
        distinct = false;
        break;
      default:
        jj_la1[81] = jj_gen;
        ;
      }
      choice = 1;
      break;
    case K_INTERSECT:
      jj_consume_token(K_INTERSECT);
      choice = 2;
      break;
    case K_EXCEPT:
    case K_MINUS:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case K_MINUS:
        jj_consume_token(K_MINUS);
        break;
      case K_EXCEPT:
        jj_consume_token(K_EXCEPT);
        break;
      default:
        jj_la1[82] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      choice = 3;
      break;
    default:
      jj_la1[83] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    if (jj_2_7(2147483647)) {
      jj_consume_token(125);
      selectWithoutOrder = SelectWithoutOrder();
      jj_consume_token(127);
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case K_SELECT:
        selectWithoutOrder = SelectWithoutOrder();
        break;
      default:
        jj_la1[84] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    if (distinct) {
      setClause = Distincts.newDistinct(setClause);
      selectWithoutOrder = Distincts.newDistinct(selectWithoutOrder);
    }
    switch (choice) {
    case 1:
      {if (true) return Unions.newUnion(setClause, selectWithoutOrder);}
      break;
    case 2:
      {if (true) return Intersects.newIntersect(setClause, selectWithoutOrder);}
      break;
    case 3:
      {if (true) return Excepts.newExcept(setClause, selectWithoutOrder);}
      break;
    }
    throw new Error("Missing return statement in function");
  }

  /**
   * This method represents the rule
   * <pre>
   * OrderByClause ::= ORDER BY SqlSimpleExpression [ ASC | DESC ] ( , SqlSimpleExpression [ ASC | DESC ] )*
   * </pre>
   *
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public void OrderByClause() throws ParseException {
    ArrayList<Node> aggregates = new ArrayList<Node>();
    jj_consume_token(K_ORDER);
    jj_consume_token(K_BY);
    SqlSimpleExpression(aggregates);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_ASC:
    case K_DESC:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case K_ASC:
        jj_consume_token(K_ASC);
        break;
      case K_DESC:
        jj_consume_token(K_DESC);
        break;
      default:
        jj_la1[85] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[86] = jj_gen;
      ;
    }
    label_7:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 126:
        ;
        break;
      default:
        jj_la1[87] = jj_gen;
        break label_7;
      }
      jj_consume_token(126);
      SqlSimpleExpression(aggregates);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case K_ASC:
      case K_DESC:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case K_ASC:
          jj_consume_token(K_ASC);
          break;
        case K_DESC:
          jj_consume_token(K_DESC);
          break;
        default:
          jj_la1[88] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[89] = jj_gen;
        ;
      }
    }
    if (aggregates.size() > 0)
      {if (true) throw new ParseException("aggregates cannot be contained by an ORDER BY clause");}
    {if (true) throw new UnsupportedOperationException("an ORDER BY clause has been parsed successfully, but ORDER BY clauses are not yet supported");}
  }

  /**
   * This method represents the rule
   * <pre>
   * ForUpdateClause ::= FOR UPDATE [ OF TableColumnList ]
   * </pre>
   *
   * <b>13/02/06 T. Riemenschneider</b> Replaced former definition<br>
   * <pre>ForUpdateClause ::= FOR UPDATE [ OF TableColumn ( "," TableColumn )* ]</pre></p>
   *
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public void ForUpdateClause() throws ParseException {
    ArrayList<Node> tableColumnList = new ArrayList<Node>();
    jj_consume_token(K_FOR);
    jj_consume_token(K_UPDATE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_OF:
      jj_consume_token(K_OF);
      TableColumnList(tableColumnList);
      break;
    default:
      jj_la1[90] = jj_gen;
      ;
    }
    {if (true) throw new UnsupportedOperationException("a FOR UPDATE clause has been parsed successfully, but FOR UPDATE clauses are not yet supported");}
  }

  /**
   * This method represents the rule
   * <pre>
   * SqlExpression ::= SqlAndExpression ( OR SqlAndExpression )*
   * </pre>
   *
   * @param aggregates a list used for collecting the aggregate calls.
   * @return the parsed SQL expression.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public Node SqlExpression(List<Node> aggregates) throws ParseException {
    ArrayList<Node> sqlAndExpressions = new ArrayList<Node>();
    Node sqlAndExpression;
    sqlAndExpression = SqlAndExpression(aggregates);
    sqlAndExpressions.add(sqlAndExpression);
    label_8:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case K_OR:
        ;
        break;
      default:
        jj_la1[91] = jj_gen;
        break label_8;
      }
      jj_consume_token(K_OR);
      sqlAndExpression = SqlAndExpression(aggregates);
      sqlAndExpressions.add(sqlAndExpression);
    }
    {if (true) return sqlAndExpressions.size() == 1 ? sqlAndExpression : LogicalOperations.newOr(sqlAndExpressions.iterator());}
    throw new Error("Missing return statement in function");
  }

  /**
   * This method represents the rule
   * <pre>
   * SqlAndExpression ::= SqlUnaryLogicalExpression ( AND SqlUnaryLogicalExpression )*
   * </pre>
   *
   * @param aggregates a list used for collecting the aggregate calls.
   * @return the parsed AND expression.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public Node SqlAndExpression(List<Node> aggregates) throws ParseException {
    ArrayList<Node> sqlUnaryLogicalExpressions = new ArrayList<Node>();
    Node sqlUnaryLogicalExpression;
    sqlUnaryLogicalExpression = SqlUnaryLogicalExpression(aggregates);
    sqlUnaryLogicalExpressions.add(sqlUnaryLogicalExpression);
    label_9:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case K_AND:
        ;
        break;
      default:
        jj_la1[92] = jj_gen;
        break label_9;
      }
      jj_consume_token(K_AND);
      sqlUnaryLogicalExpression = SqlUnaryLogicalExpression(aggregates);
      sqlUnaryLogicalExpressions.add(sqlUnaryLogicalExpression);
    }
    {if (true) return sqlUnaryLogicalExpressions.size() == 1 ? sqlUnaryLogicalExpression : LogicalOperations.newAnd(sqlUnaryLogicalExpressions.iterator());}
    throw new Error("Missing return statement in function");
  }

  /**
   * This method represents the rule
   * <pre>
   * SqlUnaryLogicalExpression ::= ExistsClause
   *                             | [ NOT ] SqlRelationalExpression
   * </pre>
   *
   * @param aggregates a list used for collecting the aggregate calls.
   * @return the parsed unary logical expression.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public Node SqlUnaryLogicalExpression(List<Node> aggregates) throws ParseException {
    Node sqlUnaryLogicalExpression;
    boolean not = false;
    if (jj_2_8(2)) {
      sqlUnaryLogicalExpression = ExistsClause();
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case K_CASE:
      case K_COUNT:
      case K_MAX:
      case K_MIN:
      case K_NOT:
      case K_NULL:
      case K_PRIOR:
      case K_STDDEV_POP:
      case K_STDDEV_SAMP:
      case K_SUM:
      case K_VAR_POP:
      case K_VAR_SAMP:
      case S_NUMBER:
      case S_IDENTIFIER:
      case S_BIND:
      case S_CHAR_LITERAL:
      case S_QUOTED_IDENTIFIER:
      case 125:
      case 138:
      case 139:
      case 148:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case K_NOT:
          jj_consume_token(K_NOT);
          not = true;
          break;
        default:
          jj_la1[93] = jj_gen;
          ;
        }
        sqlUnaryLogicalExpression = SqlRelationalExpression(aggregates);
        break;
      default:
        jj_la1[94] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    {if (true) return not ? LogicalOperations.newNot(sqlUnaryLogicalExpression) : sqlUnaryLogicalExpression;}
    throw new Error("Missing return statement in function");
  }

  /**
   * This method represents the rule
   * <pre>
   * ExistsClause ::= [ NOT ] EXISTS ( SubQuery )
   * </pre>
   *
   * @return the parsed EXISTS clause.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public Node ExistsClause() throws ParseException {
    boolean not = false;
    Node existsClause;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_NOT:
      jj_consume_token(K_NOT);
      not = true;
      break;
    default:
      jj_la1[95] = jj_gen;
      ;
    }
    jj_consume_token(K_EXISTS);
    jj_consume_token(125);
    existsClause = SubQuery();
    jj_consume_token(127);
    existsClause = LogicalOperations.newExists(existsClause);
    if (not)
      existsClause = LogicalOperations.newNot(existsClause);
    {if (true) return existsClause;}
    throw new Error("Missing return statement in function");
  }

  /**
   * This method represents the rule
   * <pre>
   * SqlRelationalExpression ::= ( [ PRIOR ] SqlSimpleExpression | "(" SqlExpressionList ")" ) ( SqlRelationalOperatorExpression | SqlInClause | SqlBetweenClause | SqlLikeClause | IsNullClause )?
   * </pre>
   *
   * @param aggregates a list used for collecting the aggregate calls.
   * @return the parsed relational expression.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public Node SqlRelationalExpression(List<Node> aggregates) throws ParseException {
    Node sqlRelationalExpression;
    if (jj_2_9(2147483647)) {
      jj_consume_token(125);
      SqlExpressionList(aggregates);
      jj_consume_token(127);
      {if (true) throw new UnsupportedOperationException("a list of SQL expressions has been parsed successfully, but lists of SQL expressions are not yet supported");}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case K_CASE:
      case K_COUNT:
      case K_MAX:
      case K_MIN:
      case K_NULL:
      case K_PRIOR:
      case K_STDDEV_POP:
      case K_STDDEV_SAMP:
      case K_SUM:
      case K_VAR_POP:
      case K_VAR_SAMP:
      case S_NUMBER:
      case S_IDENTIFIER:
      case S_BIND:
      case S_CHAR_LITERAL:
      case S_QUOTED_IDENTIFIER:
      case 125:
      case 138:
      case 139:
      case 148:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case K_PRIOR:
          jj_consume_token(K_PRIOR);
          {if (true) throw new UnsupportedOperationException("a PRIOR token has been parsed successfully, but PRIOR tokens are not yet supported");}
          break;
        default:
          jj_la1[96] = jj_gen;
          ;
        }
        sqlRelationalExpression = SqlSimpleExpression(aggregates);
        break;
      default:
        jj_la1[97] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_BETWEEN:
    case K_IN:
    case K_IS:
    case K_LIKE:
    case K_NOT:
    case 129:
    case 131:
    case 132:
    case 133:
    case 134:
    case 135:
    case 136:
    case 137:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 129:
      case 131:
      case 132:
      case 133:
      case 134:
      case 135:
      case 136:
      case 137:
        sqlRelationalExpression = SqlRelationalOperatorExpression(sqlRelationalExpression, aggregates);
        break;
      default:
        jj_la1[98] = jj_gen;
        if (jj_2_10(2)) {
          sqlRelationalExpression = SqlInClause(sqlRelationalExpression, aggregates);
        } else if (jj_2_11(2)) {
          SqlBetweenClause(aggregates);
          {if (true) throw new UnsupportedOperationException("Die SQLBetweenClause wird noch nicht unterst\u00fctzt.");}
        } else if (jj_2_12(2)) {
          SqlLikeClause(aggregates);
          {if (true) throw new UnsupportedOperationException("Die SQLLikeClause wird noch nicht unterst\u00fctzt.");}
        } else {
          switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
          case K_IS:
            sqlRelationalExpression = IsNullClause(sqlRelationalExpression);
            break;
          default:
            jj_la1[99] = jj_gen;
            jj_consume_token(-1);
            throw new ParseException();
          }
        }
      }
      break;
    default:
      jj_la1[100] = jj_gen;
      ;
    }
    {if (true) return sqlRelationalExpression;}
    throw new Error("Missing return statement in function");
  }

  /**
   * This method represents the rule
   * <pre>
   * SqlExpressionList ::= SqlSimpleExpressionOrPreparedCol ( , SqlSimpleExpressionOrPreparedCol )*
   * </pre>
   *
   * @param aggregates a list used for collecting the aggregate calls.
   * @return the parsed expression list.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public List<Node> SqlExpressionList(List<Node> aggregates) throws ParseException {
    Node sqlSimpleExpressionOrPreparedCol;
    ArrayList<Node> sqlExpressionList = new ArrayList<Node>();
    sqlSimpleExpressionOrPreparedCol = SqlSimpleExpressionOrPreparedCol(aggregates);
    sqlExpressionList.add(sqlSimpleExpressionOrPreparedCol);
    label_10:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 126:
        ;
        break;
      default:
        jj_la1[101] = jj_gen;
        break label_10;
      }
      jj_consume_token(126);
      sqlSimpleExpressionOrPreparedCol = SqlSimpleExpressionOrPreparedCol(aggregates);
      sqlExpressionList.add(sqlSimpleExpressionOrPreparedCol);
    }
    {if (true) return sqlExpressionList;}
    throw new Error("Missing return statement in function");
  }

  /**
   * This method represents the rule
   * <pre>
   * SqlRelationalOperatorExpression ::= Relop ( ( [ ALL | ANY ] "(" SubQuery ")" ) | [ PRIOR ] SqlSimpleExpressionOrPreparedCol )
   * </pre>
   *
   * @param sqlSimpleExpression the first argument of the relational operation.
   * @param aggregates a list used for collecting the aggregate calls.
   * @return the parsed relational operation.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public Node SqlRelationalOperatorExpression(Node sqlSimpleExpression, List<Node> aggregates) throws ParseException {
    Comparisons.Type type;
    Node sqlSimpleExpressionOrPreparedCol;
    type = Relop();
    if (jj_2_13(2147483647)) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case K_ALL:
      case K_ANY:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case K_ALL:
          jj_consume_token(K_ALL);
          break;
        case K_ANY:
          jj_consume_token(K_ANY);
          break;
        default:
          jj_la1[102] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        break;
      default:
        jj_la1[103] = jj_gen;
        ;
      }
      jj_consume_token(125);
      SubQuery();
      jj_consume_token(127);
      {if (true) throw new UnsupportedOperationException("a relational operator expression containing a subquery has been parsed successfully, but relational operator expressions containing suqueries are not yet supported");}
    } else {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case K_CASE:
      case K_COUNT:
      case K_MAX:
      case K_MIN:
      case K_NULL:
      case K_PRIOR:
      case K_STDDEV_POP:
      case K_STDDEV_SAMP:
      case K_SUM:
      case K_VAR_POP:
      case K_VAR_SAMP:
      case S_NUMBER:
      case S_IDENTIFIER:
      case S_BIND:
      case S_CHAR_LITERAL:
      case S_QUOTED_IDENTIFIER:
      case 125:
      case 138:
      case 139:
      case 144:
      case 148:
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case K_PRIOR:
          jj_consume_token(K_PRIOR);
          {if (true) throw new UnsupportedOperationException("a PRIOR token has been parsed successfully, but PRIOR tokens are not yet supported");}
          break;
        default:
          jj_la1[104] = jj_gen;
          ;
        }
        sqlSimpleExpressionOrPreparedCol = SqlSimpleExpressionOrPreparedCol(aggregates);
        break;
      default:
        jj_la1[105] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    {if (true) return Comparisons.newComparison(type, sqlSimpleExpression, sqlSimpleExpressionOrPreparedCol);}
    throw new Error("Missing return statement in function");
  }

  /**
   * This method represents the rule
   * <pre>
   * SqlSimpleExpressionOrPreparedCol ::= SqlSimpleExpression
   *                                    | PreparedCol
   * </pre>
   *
   * @param aggregates a list used for collecting the aggregate calls.
   * @return the parsed simple expression or prepared column.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public Node SqlSimpleExpressionOrPreparedCol(List<Node> aggregates) throws ParseException {
    Node sqlSimpleExpressionOrPreparedCol;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_CASE:
    case K_COUNT:
    case K_MAX:
    case K_MIN:
    case K_NULL:
    case K_STDDEV_POP:
    case K_STDDEV_SAMP:
    case K_SUM:
    case K_VAR_POP:
    case K_VAR_SAMP:
    case S_NUMBER:
    case S_IDENTIFIER:
    case S_BIND:
    case S_CHAR_LITERAL:
    case S_QUOTED_IDENTIFIER:
    case 125:
    case 138:
    case 139:
    case 148:
      sqlSimpleExpressionOrPreparedCol = SqlSimpleExpression(aggregates);
      break;
    case 144:
      sqlSimpleExpressionOrPreparedCol = PreparedCol();
      break;
    default:
      jj_la1[106] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return sqlSimpleExpressionOrPreparedCol;}
    throw new Error("Missing return statement in function");
  }

  /**
   * This method represents the rule
   * <pre>
   * PreparedCol ::= ?
   * </pre>
   *
   * @return the parsed prepared column.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public Node PreparedCol() throws ParseException {
    jj_consume_token(144);
    {if (true) throw new UnsupportedOperationException("a prepared column has been parsed successfully, but prepared columns are not yet supported");}
    throw new Error("Missing return statement in function");
  }

  /**
   * This method represents the rule
   * <pre>
   * SqlInClause ::= [ NOT ] IN "(" ( SqlExpressionList | SubQuery ) ")"
   * </pre>
   *
   * @param sqlRelationalExpression the relational expression that should be
   *        tested for being part of the IN clause's expression list and
   *        subquery respectively.
   * @param aggregates a list used for collecting the aggregate calls.
   * @return the parsed IN clause.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public Node SqlInClause(Node sqlRelationalExpression, List<Node> aggregates) throws ParseException {
    boolean not = false;
    List<Node> sqlExpressionList;
    Node sqlInClause;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_NOT:
      jj_consume_token(K_NOT);
      not = true;
      break;
    default:
      jj_la1[107] = jj_gen;
      ;
    }
    jj_consume_token(K_IN);
    jj_consume_token(125);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_CASE:
    case K_COUNT:
    case K_MAX:
    case K_MIN:
    case K_NULL:
    case K_STDDEV_POP:
    case K_STDDEV_SAMP:
    case K_SUM:
    case K_VAR_POP:
    case K_VAR_SAMP:
    case S_NUMBER:
    case S_IDENTIFIER:
    case S_BIND:
    case S_CHAR_LITERAL:
    case S_QUOTED_IDENTIFIER:
    case 125:
    case 138:
    case 139:
    case 144:
    case 148:
      sqlExpressionList = SqlExpressionList(aggregates);
      sqlInClause = Enumerations.newEnumeration(sqlExpressionList.iterator());
      break;
    case K_SELECT:
      sqlInClause = SubQuery();
      break;
    default:
      jj_la1[108] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    jj_consume_token(127);
    sqlInClause = LogicalOperations.newIn(sqlRelationalExpression, sqlInClause);
    if (not)
      sqlInClause = LogicalOperations.newNot(sqlInClause);
    {if (true) return sqlInClause;}
    throw new Error("Missing return statement in function");
  }

  /**
   * This method represents the rule
   * <pre>
   * SqlBetweenClause ::= [ NOT ] BETWEEN SqlSimpleExpressionOrPreparedCol AND SqlSimpleExpressionOrPreparedCol
   * </pre>
   *
   * @param aggregates a list used for collecting the aggregate calls.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public void SqlBetweenClause(List<Node> aggregates) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_NOT:
      jj_consume_token(K_NOT);
      break;
    default:
      jj_la1[109] = jj_gen;
      ;
    }
    jj_consume_token(K_BETWEEN);
    SqlSimpleExpressionOrPreparedCol(aggregates);
    jj_consume_token(K_AND);
    SqlSimpleExpressionOrPreparedCol(aggregates);
    {if (true) throw new UnsupportedOperationException("a BETWEEN clause has been parsed successfully, but BETWEEN clauses are not yet supported");}
  }

  /**
   * This method represents the rule
   * <pre>
   * SqlLikeClause ::= [ NOT ] LIKE SqlSimpleExpressionOrPreparedCol
   * </pre>
   *
   * @param aggregates a list used for collecting the aggregate calls.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public void SqlLikeClause(List<Node> aggregates) throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_NOT:
      jj_consume_token(K_NOT);
      break;
    default:
      jj_la1[110] = jj_gen;
      ;
    }
    jj_consume_token(K_LIKE);
    SqlSimpleExpressionOrPreparedCol(aggregates);
    {if (true) throw new UnsupportedOperationException("a LIKE clause has been parsed successfully, but LIKE clauses are not yet supported");}
  }

  /**
   * This method represents the rule
   * <pre>
   * IsNullClause ::= IS [ NOT ] NULL
   * </pre>
   *
   * @param sqlSimpleExpression the argument of the IS NULL clause.
   * @return the parsed IS NULL clause.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public Node IsNullClause(Node sqlSimpleExpression) throws ParseException {
    boolean not = false;
    jj_consume_token(K_IS);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_NOT:
      jj_consume_token(K_NOT);
      not = true;
      break;
    default:
      jj_la1[111] = jj_gen;
      ;
    }
    jj_consume_token(K_NULL);
    {if (true) return Comparisons.newComparison(not ? Comparisons.Type.UNEQUAL : Comparisons.Type.EQUAL, sqlSimpleExpression, Constants.newNull());}
    throw new Error("Missing return statement in function");
  }

  /**
   * This method represents the rule
   * <pre>
   * SqlSimpleExpression ::= SqlMultiplicativeExpression ( OP SqlMultiplicativeExpression )*
   * OP ::= +
   *      | -
   *      | "||"
   * </pre>
   *
   * @param aggregates a list used for collecting the aggregate calls.
   * @return the parsed simple expression.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public Node SqlSimpleExpression(List<Node> aggregates) throws ParseException {
    Node sqlSimpleExpression;
    Node sqlMultiplicativeExpression;
    sqlSimpleExpression = SqlMultiplicativeExpression(aggregates);
    label_11:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 138:
      case 139:
      case 145:
        ;
        break;
      default:
        jj_la1[112] = jj_gen;
        break label_11;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 138:
        jj_consume_token(138);
        sqlMultiplicativeExpression = SqlMultiplicativeExpression(aggregates);
        sqlSimpleExpression  = xxl.core.relational.query.expressions.Operations.newAddition(sqlSimpleExpression, sqlMultiplicativeExpression);
        break;
      case 139:
        jj_consume_token(139);
        sqlMultiplicativeExpression = SqlMultiplicativeExpression(aggregates);
        sqlSimpleExpression  = xxl.core.relational.query.expressions.Operations.newSubtraction(sqlSimpleExpression, sqlMultiplicativeExpression);
        break;
      case 145:
        jj_consume_token(145);
        sqlMultiplicativeExpression = SqlMultiplicativeExpression(aggregates);
        sqlSimpleExpression  = xxl.core.relational.query.expressions.Operations.newConcatenation(sqlSimpleExpression, sqlMultiplicativeExpression);
        break;
      default:
        jj_la1[113] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    {if (true) return sqlSimpleExpression;}
    throw new Error("Missing return statement in function");
  }

  /**
   * This method represents the rule
   * <pre>
   * SqlMultiplicativeExpression ::= SqlExpotentExpression ( OP SqlExpotentExpression )*
   * OP ::= *
   *      | /
   * </pre>
   *
   * @param aggregates a list used for collecting the aggregate calls.
   * @return the parsed multiplicative expression.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public Node SqlMultiplicativeExpression(List<Node> aggregates) throws ParseException {
    Node sqlMultiplicativeExpression;
    Node sqlExpotentExpression;
    sqlMultiplicativeExpression = SqlExpotentExpression(aggregates);
    label_12:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 140:
      case 146:
        ;
        break;
      default:
        jj_la1[114] = jj_gen;
        break label_12;
      }
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 140:
        jj_consume_token(140);
        sqlExpotentExpression = SqlExpotentExpression(aggregates);
        sqlMultiplicativeExpression  = xxl.core.relational.query.expressions.Operations.newMultiplication(sqlMultiplicativeExpression, sqlExpotentExpression);
        break;
      case 146:
        jj_consume_token(146);
        sqlExpotentExpression = SqlExpotentExpression(aggregates);
        sqlMultiplicativeExpression  = xxl.core.relational.query.expressions.Operations.newDivision(sqlMultiplicativeExpression, sqlExpotentExpression);
        break;
      default:
        jj_la1[115] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
    }
    {if (true) return sqlMultiplicativeExpression;}
    throw new Error("Missing return statement in function");
  }

  /**
   * This method represents the rule
   * <pre>
   * SqlExpotentExpression ::= SqlUnaryExpression ( ** SqlUnaryExpression )*
   * </pre>
   *
   * @param aggregates a list used for collecting the aggregate calls.
   * @return the parsed expoential expression.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public Node SqlExpotentExpression(List<Node> aggregates) throws ParseException {
    Node sqlExpotentExpression;
    Node sqlUnaryExpression;
    sqlExpotentExpression = SqlUnaryExpression(aggregates);
    label_13:
    while (true) {
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 147:
        ;
        break;
      default:
        jj_la1[116] = jj_gen;
        break label_13;
      }
      jj_consume_token(147);
      sqlUnaryExpression = SqlUnaryExpression(aggregates);
      sqlExpotentExpression = xxl.core.relational.query.expressions.Operations.newExponentiation(sqlExpotentExpression, sqlUnaryExpression);
    }
    {if (true) return sqlExpotentExpression;}
    throw new Error("Missing return statement in function");
  }

  /**
   * This method represents the rule
   * <pre>
   * SqlUnaryExpression ::= [ + | - ] SqlPrimaryExpression
   * </pre>
   *
   * @param aggregates a list used for collecting the aggregate calls.
   * @return the parsed unary expression.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public Node SqlUnaryExpression(List<Node> aggregates) throws ParseException {
    boolean negative = false;
    Node sqlPrimaryExpression;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 138:
    case 139:
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 138:
        jj_consume_token(138);
        break;
      case 139:
        jj_consume_token(139);
        negative = true;
        break;
      default:
        jj_la1[117] = jj_gen;
        jj_consume_token(-1);
        throw new ParseException();
      }
      break;
    default:
      jj_la1[118] = jj_gen;
      ;
    }
    sqlPrimaryExpression = SqlPrimaryExpression(aggregates);
    {if (true) return negative ? xxl.core.relational.query.expressions.Operations.newMinus(sqlPrimaryExpression) : sqlPrimaryExpression;}
    throw new Error("Missing return statement in function");
  }

  /**
   * This method represents the rule
   * <pre>
   * SqlPrimaryExpression ::= NULL
   *                        | OuterJoinExpression
   *                        | AggregateFunc "(" [ ALL | DISTINCT ] TableColumn ")"
   *                        | FunctionCall
   *                        | TableColumn
   *                        | COUNT(*)
   *                        | &lt;S_NUMBER&gt;
   *                        | &lt;S_CHAR_LITERAL&gt;
   *                        | &lt;S_BIND&gt;
   * </pre>
   *
   * <p><b>VERSION INFO:</b><br>
   * <b>01/07/00 PY. Gibello</b> Added COUNT(*) to SqlPrimaryExpression<br>
   * <b>01/06/02 PY. Gibello</b> Added ALL | DISTINCT (then the column name
   * starts with "all " or "distinct " when required, which may not be the
   * fairest solution...)</p>
   *
   * @param aggregates a list used for collecting the aggregate calls.
   * @return the parsed primary expression.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public Node SqlPrimaryExpression(List<Node> aggregates) throws ParseException {
    Node tableColumn;
    Node functionCall;
    Aggregates.Type aggregateType;
    Aggregates.Mode mode = Aggregates.Mode.ALL;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_NULL:
      jj_consume_token(K_NULL);
      {if (true) return Constants.newNull();}
      break;
    default:
      jj_la1[120] = jj_gen;
      if (jj_2_14(2147483647)) {
        tableColumn = OuterJoinExpression();
        {if (true) return tableColumn;}
      } else if (jj_2_15(3)) {
        jj_consume_token(K_COUNT);
        jj_consume_token(125);
        jj_consume_token(140);
        jj_consume_token(127);
        {if (true) throw new UnsupportedOperationException("a COUNT(*) expression has been parsed successfully, but COUNT(*) expressions are not yet supported");}
      } else if (jj_2_16(3)) {
        aggregateType = AggregateFunc();
        jj_consume_token(125);
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case K_ALL:
          jj_consume_token(K_ALL);
          break;
        case K_DISTINCT:
          jj_consume_token(K_DISTINCT);
          mode = Aggregates.Mode.DISTINCT;
          break;
        default:
          jj_la1[119] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
        tableColumn = TableColumn();
        jj_consume_token(127);
        functionCall = Aggregates.newAggregate(aggregateType, 1, mode, tableColumn);
        int i = aggregates.indexOf(functionCall);
        if (i == -1) {
          aggregates.add(functionCall);
          {if (true) return functionCall;}
        }
        {if (true) return aggregates.get(i);}
      } else if (jj_2_17(2)) {
        functionCall = FunctionCall(aggregates);
        {if (true) return functionCall;}
      } else {
        switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
        case S_IDENTIFIER:
        case S_QUOTED_IDENTIFIER:
          tableColumn = TableColumn();
          {if (true) return tableColumn;}
          break;
        case S_NUMBER:
          jj_consume_token(S_NUMBER);
          try {
            {if (true) return Constants.newConstant(Integer.parseInt(token.image));}
          }
          catch (NumberFormatException nfe) {
            {if (true) return Constants.newConstant(Double.parseDouble(token.image));}
          }
          break;
        case S_CHAR_LITERAL:
          jj_consume_token(S_CHAR_LITERAL);
          {if (true) return Constants.newConstant(token.image);}
          break;
        case S_BIND:
          jj_consume_token(S_BIND);
          {if (true) throw new UnsupportedOperationException("a table binding expression has been parsed successfully, but table binding expressions are not yet supported");}
          break;
        case 125:
          jj_consume_token(125);
          tableColumn = SqlExpression(aggregates);
          jj_consume_token(127);
          {if (true) return tableColumn;}
          break;
        default:
          jj_la1[121] = jj_gen;
          jj_consume_token(-1);
          throw new ParseException();
        }
      }
    }
    throw new Error("Missing return statement in function");
  }

  /**
   * This method represents the rule
   * <pre>
   * AggregateFunc ::= AVG
   *                 | COUNT
   *                 | MAX
   *                 | MIN
   *                 | STDDEV_POP
   *                 | STDDEV_SAMP
   *                 | SUM
   *                 | VAR_POP
   *                 | VAR_SAMP
   * </pre>
   *
   * <p><b>VERSION INFO:</b><br>
   * <b>01/07/00 PY. Gibello</b> Added COUNT<br>
   * <b>20/02/06 T. Riemenschneider</b> Added STDDEV and VAR</p>
   *
   * @return the parsed aggregate function.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public Aggregates.Type AggregateFunc() throws ParseException {
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 148:
      jj_consume_token(148);
      {if (true) return Aggregates.Type.AVERAGE;}
      break;
    case K_COUNT:
      jj_consume_token(K_COUNT);
      {if (true) return Aggregates.Type.COUNT;}
      break;
    case K_MAX:
      jj_consume_token(K_MAX);
      {if (true) return Aggregates.Type.MAXIMUM;}
      break;
    case K_MIN:
      jj_consume_token(K_MIN);
      {if (true) return Aggregates.Type.MINIMUM;}
      break;
    case K_STDDEV_POP:
      jj_consume_token(K_STDDEV_POP);
      {if (true) return Aggregates.Type.STANDARD_DEVIATION_POPULATION;}
      break;
    case K_STDDEV_SAMP:
      jj_consume_token(K_STDDEV_SAMP);
      {if (true) return Aggregates.Type.STANDARD_DEVIATION_SAMPLE;}
      break;
    case K_SUM:
      jj_consume_token(K_SUM);
      {if (true) return Aggregates.Type.SUM;}
      break;
    case K_VAR_POP:
      jj_consume_token(K_VAR_POP);
      {if (true) return Aggregates.Type.VARIANCE_POPULATION;}
      break;
    case K_VAR_SAMP:
      jj_consume_token(K_VAR_SAMP);
      {if (true) return Aggregates.Type.VARIANCE_SAMPLE;}
      break;
    default:
      jj_la1[122] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  /**
   * This method represents the rule
   * <pre>
   * FunctionCall ::= AggregateFunc "(" SqlExpressionList ")"
   *                | &lt;S_IDENTIFIER&gt; "(" SqlExpressionList ")"
   *                | CaseCall
   * </pre>
   *
   * <p><b>VERSION INFO:</b><br>
   * <b>13/02/06 T. Riemenschneider</b> Replaced former definition<br>
   * <pre>FunctionCall ::= ( &lt;S_IDENTIFIER&gt; | AggregateFunc ) "(" SqlExpressionList ")"</pre></p>
   *
   * @param aggregates a list used for collecting the aggregate calls.
   * @return the parsed function call.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public Node FunctionCall(List<Node> aggregates) throws ParseException {
    Node functionCall;
    Aggregates.Type aggregateType;
    List<Node> sqlExpressionList;
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_CASE:
      functionCall = CaseCall(aggregates);
      {if (true) return functionCall;}
      break;
    case K_COUNT:
    case K_MAX:
    case K_MIN:
    case K_STDDEV_POP:
    case K_STDDEV_SAMP:
    case K_SUM:
    case K_VAR_POP:
    case K_VAR_SAMP:
    case 148:
      aggregateType = AggregateFunc();
      jj_consume_token(125);
      sqlExpressionList = SqlExpressionList(aggregates);
      jj_consume_token(127);
      functionCall = Aggregates.newAggregate(aggregateType, sqlExpressionList.size(), sqlExpressionList.iterator());
      int i = aggregates.indexOf(functionCall);
      if (i == -1) {
        aggregates.add(functionCall);
        {if (true) return functionCall;}
      }
      {if (true) return aggregates.get(i);}
      break;
    case S_IDENTIFIER:
      jj_consume_token(S_IDENTIFIER);
      jj_consume_token(125);
      sqlExpressionList = SqlExpressionList(aggregates);
      jj_consume_token(127);
      {if (true) throw new UnsupportedOperationException("a " + token.image + " function call has been parsed successfully, but " + token.image + " function calls are not yet supported");}
      break;
    default:
      jj_la1[123] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    throw new Error("Missing return statement in function");
  }

  /**
   * This method represents the rule
   * <pre>
   * CaseCall ::= CASE ( SimpleCaseCall | BooleanCaseCall )
   * </pre>
   *
   * <p><b>VERSION INFO:</b><br>
   * <b>13/02/06 T. Riemenschneider</b> Added CASE function</pre></p>
   *
   * @param aggregates a list used for collecting the aggregate calls.
   * @return the parsed CASE function call.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public Node CaseCall(List<Node> aggregates) throws ParseException {
    Node caseCall;
    jj_consume_token(K_CASE);
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_CASE:
    case K_COUNT:
    case K_MAX:
    case K_MIN:
    case K_NULL:
    case K_STDDEV_POP:
    case K_STDDEV_SAMP:
    case K_SUM:
    case K_VAR_POP:
    case K_VAR_SAMP:
    case S_NUMBER:
    case S_IDENTIFIER:
    case S_BIND:
    case S_CHAR_LITERAL:
    case S_QUOTED_IDENTIFIER:
    case 125:
    case 138:
    case 139:
    case 148:
      caseCall = SimpleCaseCall(aggregates);
      break;
    case K_WHEN:
      caseCall = BooleanCaseCall(aggregates);
      break;
    default:
      jj_la1[124] = jj_gen;
      jj_consume_token(-1);
      throw new ParseException();
    }
    {if (true) return caseCall;}
    throw new Error("Missing return statement in function");
  }

  /**
   * This method represents the rule
   * <pre>
   * SimpleCaseCall ::= SqlSimpleExpression ( WHEN SqlSimpleExpression THEN SqlSimpleExpression )+ [ ELSE SqlSimpleExpression ] END
   * </pre>
   *
   * <p><b>VERSION INFO:</b><br>
   * <b>13/02/06 T. Riemenschneider</b> Added simple CASE function</pre></p>
   *
   * @param aggregates a list used for collecting the aggregate calls.
   * @return the parsed simple CASE function call.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public Node SimpleCaseCall(List<Node> aggregates) throws ParseException {
    Node pattern;
    Node sqlSimpleExpression;
    ArrayList<Node> conditions = new ArrayList<Node>();
    ArrayList<Node> results = new ArrayList<Node>();
    pattern = SqlSimpleExpression(aggregates);
    label_14:
    while (true) {
      jj_consume_token(K_WHEN);
      sqlSimpleExpression = SqlSimpleExpression(aggregates);
      conditions.add(Comparisons.newEqualComparison(pattern, sqlSimpleExpression));
      jj_consume_token(K_THEN);
      sqlSimpleExpression = SqlSimpleExpression(aggregates);
      results.add(sqlSimpleExpression);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case K_WHEN:
        ;
        break;
      default:
        jj_la1[125] = jj_gen;
        break label_14;
      }
    }
    conditions.add(xxl.core.relational.query.predicates.LogicalConstants.newTrue());
    sqlSimpleExpression = Constants.newNull();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_ELSE:
      jj_consume_token(K_ELSE);
      sqlSimpleExpression = SqlSimpleExpression(aggregates);
      break;
    default:
      jj_la1[126] = jj_gen;
      ;
    }
    results.add(sqlSimpleExpression);
    jj_consume_token(K_END);
    {if (true) return Functions.newCase(conditions.iterator(), results.iterator());}
    throw new Error("Missing return statement in function");
  }

  /**
   * This method represents the rule
   * <pre>
   * BooleanCaseCall ::= ( WHEN SqlExpression THEN SqlSimpleExpression )+ [ ELSE SqlSimpleExpression ] END
   * </pre>
   *
   * <p><b>VERSION INFO:</b><br>
   * <b>13/02/06 T. Riemenschneider</b> Added boolean CASE function</pre></p>
   *
   * @param aggregates a list used for collecting the aggregate calls.
   * @return the parsed boolean CASE function call.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public Node BooleanCaseCall(List<Node> aggregates) throws ParseException {
    Node sqlExpression;
    ArrayList<Node> conditions = new ArrayList<Node>();
    ArrayList<Node> results = new ArrayList<Node>();
    label_15:
    while (true) {
      jj_consume_token(K_WHEN);
      sqlExpression = SqlExpression(aggregates);
      conditions.add(sqlExpression);
      jj_consume_token(K_THEN);
      sqlExpression = SqlSimpleExpression(aggregates);
      results.add(sqlExpression);
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case K_WHEN:
        ;
        break;
      default:
        jj_la1[127] = jj_gen;
        break label_15;
      }
    }
    conditions.add(xxl.core.relational.query.predicates.LogicalConstants.newTrue());
    sqlExpression = Constants.newNull();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case K_ELSE:
      jj_consume_token(K_ELSE);
      sqlExpression = SqlSimpleExpression(aggregates);
      break;
    default:
      jj_la1[128] = jj_gen;
      ;
    }
    results.add(sqlExpression);
    jj_consume_token(K_END);
    {if (true) return Functions.newCase(conditions.iterator(), results.iterator());}
    throw new Error("Missing return statement in function");
  }

  /**
   * This method represents the rule
   * <pre>
   * OuterJoinExpression ::= OracleObjectName [ . OracleObjectName [ . OracleObjectName ] ] "(" + ")"
   * </pre>
   *
   * <p>The outer join expression can be something like
   * <tt>schema.table.column</tt>.</p>
   *
   * @return the parsed outer join expression.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public Node OuterJoinExpression() throws ParseException {
    OracleObjectName();
    switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
    case 130:
      jj_consume_token(130);
      OracleObjectName();
      switch ((jj_ntk==-1)?jj_ntk():jj_ntk) {
      case 130:
        jj_consume_token(130);
        OracleObjectName();
        break;
      default:
        jj_la1[129] = jj_gen;
        ;
      }
      break;
    default:
      jj_la1[130] = jj_gen;
      ;
    }
    jj_consume_token(125);
    jj_consume_token(138);
    jj_consume_token(127);
    {if (true) throw new UnsupportedOperationException("an OUTER JOIN expression has been parsed successfully, but OUTER JOIN expressions are not yet supported");}
    throw new Error("Missing return statement in function");
  }

  /**
   * This method represents the rule
   * <pre>
   * SubQuery ::= SelectWithoutOrder
   * </pre>
   *
   * @return the parsed subquery.
   * @throws ParseException if an exception occurs during the process of
   *         parsing.
   */
  final public Node SubQuery() throws ParseException {
    Node selectWithoutOrder;
    selectWithoutOrder = SelectWithoutOrder();
    {if (true) return selectWithoutOrder;}
    throw new Error("Missing return statement in function");
  }

  final private boolean jj_2_1(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_1(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(0, xla); }
  }

  final private boolean jj_2_2(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_2(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(1, xla); }
  }

  final private boolean jj_2_3(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_3(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(2, xla); }
  }

  final private boolean jj_2_4(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_4(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(3, xla); }
  }

  final private boolean jj_2_5(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_5(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(4, xla); }
  }

  final private boolean jj_2_6(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_6(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(5, xla); }
  }

  final private boolean jj_2_7(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_7(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(6, xla); }
  }

  final private boolean jj_2_8(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_8(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(7, xla); }
  }

  final private boolean jj_2_9(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_9(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(8, xla); }
  }

  final private boolean jj_2_10(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_10(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(9, xla); }
  }

  final private boolean jj_2_11(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_11(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(10, xla); }
  }

  final private boolean jj_2_12(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_12(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(11, xla); }
  }

  final private boolean jj_2_13(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_13(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(12, xla); }
  }

  final private boolean jj_2_14(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_14(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(13, xla); }
  }

  final private boolean jj_2_15(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_15(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(14, xla); }
  }

  final private boolean jj_2_16(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_16(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(15, xla); }
  }

  final private boolean jj_2_17(int xla) {
    jj_la = xla; jj_lastpos = jj_scanpos = token;
    try { return !jj_3_17(); }
    catch(LookaheadSuccess ls) { return true; }
    finally { jj_save(16, xla); }
  }

  final private boolean jj_3R_70() {
    if (jj_scan_token(144)) return true;
    return false;
  }

  final private boolean jj_3R_65() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_76()) {
    jj_scanpos = xsp;
    if (jj_3R_77()) {
    jj_scanpos = xsp;
    if (jj_3R_78()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_76() {
    if (jj_scan_token(K_INNER)) return true;
    return false;
  }

  final private boolean jj_3R_53() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_65()) jj_scanpos = xsp;
    if (jj_scan_token(K_JOIN)) return true;
    if (jj_3R_50()) return true;
    xsp = jj_scanpos;
    if (jj_3R_180()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_81() {
    if (jj_3R_21()) return true;
    Token xsp;
    if (jj_3R_111()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_111()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_112()) jj_scanpos = xsp;
    if (jj_scan_token(K_END)) return true;
    return false;
  }

  final private boolean jj_3_13() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(7)) {
    jj_scanpos = xsp;
    if (jj_scan_token(5)) {
    jj_scanpos = xsp;
    if (jj_3R_25()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_59() {
    if (jj_3R_21()) return true;
    return false;
  }

  final private boolean jj_3R_36() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_59()) {
    jj_scanpos = xsp;
    if (jj_3R_60()) return true;
    }
    return false;
  }

  final private boolean jj_3R_117() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_120()) {
    jj_scanpos = xsp;
    if (jj_3_10()) {
    jj_scanpos = xsp;
    if (jj_3_11()) {
    jj_scanpos = xsp;
    if (jj_3_12()) {
    jj_scanpos = xsp;
    if (jj_3R_121()) return true;
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_120() {
    if (jj_3R_129()) return true;
    return false;
  }

  final private boolean jj_3R_71() {
    if (jj_3R_81()) return true;
    return false;
  }

  final private boolean jj_3R_141() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_166()) jj_scanpos = xsp;
    if (jj_scan_token(125)) return true;
    if (jj_3R_114()) return true;
    if (jj_scan_token(127)) return true;
    return false;
  }

  final private boolean jj_3R_167() {
    if (jj_scan_token(K_PRIOR)) return true;
    return false;
  }

  final private boolean jj_3R_62() {
    if (jj_scan_token(K_CASE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_71()) {
    jj_scanpos = xsp;
    if (jj_3R_72()) return true;
    }
    return false;
  }

  final private boolean jj_3R_187() {
    if (jj_scan_token(K_USING)) return true;
    if (jj_scan_token(125)) return true;
    if (jj_3R_181()) return true;
    if (jj_scan_token(127)) return true;
    return false;
  }

  final private boolean jj_3R_142() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_167()) jj_scanpos = xsp;
    if (jj_3R_36()) return true;
    return false;
  }

  final private boolean jj_3R_51() {
    if (jj_scan_token(K_CROSS)) return true;
    if (jj_scan_token(K_JOIN)) return true;
    if (jj_3R_50()) return true;
    return false;
  }

  final private boolean jj_3R_78() {
    if (jj_scan_token(K_UNION)) return true;
    return false;
  }

  final private boolean jj_3R_129() {
    if (jj_3R_140()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_141()) {
    jj_scanpos = xsp;
    if (jj_3R_142()) return true;
    }
    return false;
  }

  final private boolean jj_3R_88() {
    if (jj_scan_token(K_FULL)) return true;
    return false;
  }

  final private boolean jj_3R_190() {
    if (jj_scan_token(K_UNBOUNDED)) return true;
    return false;
  }

  final private boolean jj_3R_86() {
    if (jj_scan_token(K_LEFT)) return true;
    return false;
  }

  final private boolean jj_3R_87() {
    if (jj_scan_token(K_RIGHT)) return true;
    return false;
  }

  final private boolean jj_3R_77() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_86()) {
    jj_scanpos = xsp;
    if (jj_3R_87()) {
    jj_scanpos = xsp;
    if (jj_3R_88()) return true;
    }
    }
    xsp = jj_scanpos;
    if (jj_scan_token(72)) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_49() {
    if (jj_scan_token(S_IDENTIFIER)) return true;
    if (jj_scan_token(125)) return true;
    if (jj_3R_104()) return true;
    if (jj_scan_token(127)) return true;
    return false;
  }

  final private boolean jj_3R_75() {
    if (jj_scan_token(K_UNION)) return true;
    return false;
  }

  final private boolean jj_3R_48() {
    if (jj_3R_27()) return true;
    if (jj_scan_token(125)) return true;
    if (jj_3R_104()) return true;
    if (jj_scan_token(127)) return true;
    return false;
  }

  final private boolean jj_3R_85() {
    if (jj_scan_token(K_FULL)) return true;
    return false;
  }

  final private boolean jj_3R_83() {
    if (jj_scan_token(K_LEFT)) return true;
    return false;
  }

  final private boolean jj_3R_84() {
    if (jj_scan_token(K_RIGHT)) return true;
    return false;
  }

  final private boolean jj_3R_107() {
    if (jj_scan_token(126)) return true;
    if (jj_3R_36()) return true;
    return false;
  }

  final private boolean jj_3R_74() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_83()) {
    jj_scanpos = xsp;
    if (jj_3R_84()) {
    jj_scanpos = xsp;
    if (jj_3R_85()) return true;
    }
    }
    xsp = jj_scanpos;
    if (jj_scan_token(72)) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_47() {
    if (jj_3R_62()) return true;
    return false;
  }

  final private boolean jj_3R_29() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_47()) {
    jj_scanpos = xsp;
    if (jj_3R_48()) {
    jj_scanpos = xsp;
    if (jj_3R_49()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_64() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_73()) {
    jj_scanpos = xsp;
    if (jj_3R_74()) {
    jj_scanpos = xsp;
    if (jj_3R_75()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_73() {
    if (jj_scan_token(K_INNER)) return true;
    return false;
  }

  final private boolean jj_3R_104() {
    if (jj_3R_36()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_107()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_30() {
    if (jj_3R_50()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_51()) {
    jj_scanpos = xsp;
    if (jj_3R_52()) {
    jj_scanpos = xsp;
    if (jj_3R_53()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_18() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_30()) {
    jj_scanpos = xsp;
    if (jj_3R_31()) return true;
    }
    return false;
  }

  final private boolean jj_3R_189() {
    if (jj_3R_191()) return true;
    return false;
  }

  final private boolean jj_3R_109() {
    if (jj_scan_token(K_NOT)) return true;
    return false;
  }

  final private boolean jj_3R_108() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_109()) jj_scanpos = xsp;
    if (jj_3R_110()) return true;
    return false;
  }

  final private boolean jj_3R_121() {
    if (jj_3R_130()) return true;
    return false;
  }

  final private boolean jj_3R_182() {
    if (jj_scan_token(K_RANGE)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_189()) {
    jj_scanpos = xsp;
    if (jj_3R_190()) return true;
    }
    return false;
  }

  final private boolean jj_3_12() {
    if (jj_3R_24()) return true;
    return false;
  }

  final private boolean jj_3_9() {
    if (jj_scan_token(125)) return true;
    if (jj_3R_21()) return true;
    if (jj_scan_token(126)) return true;
    return false;
  }

  final private boolean jj_3R_178() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_182()) {
    jj_scanpos = xsp;
    if (jj_3R_183()) return true;
    }
    return false;
  }

  final private boolean jj_3R_119() {
    if (jj_scan_token(K_PRIOR)) return true;
    return false;
  }

  final private boolean jj_3R_63() {
    if (jj_scan_token(130)) return true;
    if (jj_3R_17()) return true;
    return false;
  }

  final private boolean jj_3R_19() {
    if (jj_scan_token(K_STREAM)) return true;
    return false;
  }

  final private boolean jj_3R_46() {
    if (jj_scan_token(K_VAR_SAMP)) return true;
    return false;
  }

  final private boolean jj_3R_116() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_119()) jj_scanpos = xsp;
    if (jj_3R_21()) return true;
    return false;
  }

  final private boolean jj_3R_45() {
    if (jj_scan_token(K_VAR_POP)) return true;
    return false;
  }

  final private boolean jj_3R_44() {
    if (jj_scan_token(K_SUM)) return true;
    return false;
  }

  final private boolean jj_3R_50() {
    if (jj_3R_17()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_63()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_115() {
    if (jj_scan_token(125)) return true;
    if (jj_3R_104()) return true;
    if (jj_scan_token(127)) return true;
    return false;
  }

  final private boolean jj_3R_43() {
    if (jj_scan_token(K_STDDEV_SAMP)) return true;
    return false;
  }

  final private boolean jj_3R_110() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_115()) {
    jj_scanpos = xsp;
    if (jj_3R_116()) return true;
    }
    xsp = jj_scanpos;
    if (jj_3R_117()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_42() {
    if (jj_scan_token(K_STDDEV_POP)) return true;
    return false;
  }

  final private boolean jj_3R_41() {
    if (jj_scan_token(K_MIN)) return true;
    return false;
  }

  final private boolean jj_3R_28() {
    if (jj_scan_token(K_DISTINCT)) return true;
    return false;
  }

  final private boolean jj_3R_40() {
    if (jj_scan_token(K_MAX)) return true;
    return false;
  }

  final private boolean jj_3R_196() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(23)) {
    jj_scanpos = xsp;
    if (jj_scan_token(24)) return true;
    }
    return false;
  }

  final private boolean jj_3R_39() {
    if (jj_scan_token(K_COUNT)) return true;
    return false;
  }

  final private boolean jj_3R_195() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(40)) {
    jj_scanpos = xsp;
    if (jj_scan_token(41)) return true;
    }
    return false;
  }

  final private boolean jj_3R_194() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(57)) {
    jj_scanpos = xsp;
    if (jj_scan_token(58)) return true;
    }
    return false;
  }

  final private boolean jj_3R_193() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(85)) {
    jj_scanpos = xsp;
    if (jj_scan_token(86)) return true;
    }
    return false;
  }

  final private boolean jj_3R_192() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_193()) {
    jj_scanpos = xsp;
    if (jj_3R_194()) {
    jj_scanpos = xsp;
    if (jj_3R_195()) {
    jj_scanpos = xsp;
    if (jj_3R_196()) return true;
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_165() {
    if (jj_scan_token(137)) return true;
    return false;
  }

  final private boolean jj_3R_38() {
    if (jj_scan_token(148)) return true;
    return false;
  }

  final private boolean jj_3R_27() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_38()) {
    jj_scanpos = xsp;
    if (jj_3R_39()) {
    jj_scanpos = xsp;
    if (jj_3R_40()) {
    jj_scanpos = xsp;
    if (jj_3R_41()) {
    jj_scanpos = xsp;
    if (jj_3R_42()) {
    jj_scanpos = xsp;
    if (jj_3R_43()) {
    jj_scanpos = xsp;
    if (jj_3R_44()) {
    jj_scanpos = xsp;
    if (jj_3R_45()) {
    jj_scanpos = xsp;
    if (jj_3R_46()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_164() {
    if (jj_scan_token(136)) return true;
    return false;
  }

  final private boolean jj_3R_163() {
    if (jj_scan_token(135)) return true;
    return false;
  }

  final private boolean jj_3R_191() {
    if (jj_scan_token(S_NUMBER)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_192()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_162() {
    if (jj_scan_token(134)) return true;
    return false;
  }

  final private boolean jj_3R_161() {
    if (jj_scan_token(133)) return true;
    return false;
  }

  final private boolean jj_3R_160() {
    if (jj_scan_token(132)) return true;
    return false;
  }

  final private boolean jj_3R_32() {
    if (jj_scan_token(K_NOT)) return true;
    return false;
  }

  final private boolean jj_3R_159() {
    if (jj_scan_token(131)) return true;
    return false;
  }

  final private boolean jj_3R_20() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_32()) jj_scanpos = xsp;
    if (jj_scan_token(K_EXISTS)) return true;
    if (jj_scan_token(125)) return true;
    if (jj_3R_114()) return true;
    if (jj_scan_token(127)) return true;
    return false;
  }

  final private boolean jj_3_6() {
    if (jj_scan_token(K_AS)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(79)) {
    jj_scanpos = xsp;
    if (jj_3R_19()) return true;
    }
    return false;
  }

  final private boolean jj_3R_184() {
    if (jj_scan_token(S_NUMBER)) return true;
    return false;
  }

  final private boolean jj_3R_158() {
    if (jj_scan_token(129)) return true;
    return false;
  }

  final private boolean jj_3R_140() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_158()) {
    jj_scanpos = xsp;
    if (jj_3R_159()) {
    jj_scanpos = xsp;
    if (jj_3R_160()) {
    jj_scanpos = xsp;
    if (jj_3R_161()) {
    jj_scanpos = xsp;
    if (jj_3R_162()) {
    jj_scanpos = xsp;
    if (jj_3R_163()) {
    jj_scanpos = xsp;
    if (jj_3R_164()) {
    jj_scanpos = xsp;
    if (jj_3R_165()) return true;
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_148() {
    if (jj_3R_50()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_170()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_171()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_96() {
    if (jj_scan_token(125)) return true;
    if (jj_3R_99()) return true;
    if (jj_scan_token(127)) return true;
    return false;
  }

  final private boolean jj_3R_185() {
    if (jj_scan_token(K_UNBOUNDED)) return true;
    return false;
  }

  final private boolean jj_3R_95() {
    if (jj_scan_token(S_BIND)) return true;
    return false;
  }

  final private boolean jj_3R_179() {
    if (jj_scan_token(K_ROWS)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_184()) {
    jj_scanpos = xsp;
    if (jj_3R_185()) return true;
    }
    return false;
  }

  final private boolean jj_3R_172() {
    if (jj_3R_176()) return true;
    return false;
  }

  final private boolean jj_3R_94() {
    if (jj_scan_token(S_CHAR_LITERAL)) return true;
    return false;
  }

  final private boolean jj_3R_183() {
    if (jj_scan_token(K_NOW)) return true;
    return false;
  }

  final private boolean jj_3R_171() {
    if (jj_3R_173()) return true;
    return false;
  }

  final private boolean jj_3R_177() {
    if (jj_scan_token(K_PARTITION)) return true;
    if (jj_scan_token(K_BY)) return true;
    if (jj_3R_181()) return true;
    return false;
  }

  final private boolean jj_3_8() {
    if (jj_3R_20()) return true;
    return false;
  }

  final private boolean jj_3R_105() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_8()) {
    jj_scanpos = xsp;
    if (jj_3R_108()) return true;
    }
    return false;
  }

  final private boolean jj_3R_93() {
    if (jj_scan_token(S_NUMBER)) return true;
    return false;
  }

  final private boolean jj_3R_176() {
    if (jj_scan_token(142)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_177()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_178()) {
    jj_scanpos = xsp;
    if (jj_3R_179()) return true;
    }
    if (jj_scan_token(143)) return true;
    xsp = jj_scanpos;
    if (jj_3_6()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_92() {
    if (jj_3R_98()) return true;
    return false;
  }

  final private boolean jj_3_17() {
    if (jj_3R_29()) return true;
    return false;
  }

  final private boolean jj_3R_17() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(119)) {
    jj_scanpos = xsp;
    if (jj_scan_token(124)) return true;
    }
    return false;
  }

  final private boolean jj_3_14() {
    if (jj_3R_26()) return true;
    return false;
  }

  final private boolean jj_3_16() {
    if (jj_3R_27()) return true;
    if (jj_scan_token(125)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(5)) {
    jj_scanpos = xsp;
    if (jj_3R_28()) return true;
    }
    if (jj_3R_98()) return true;
    if (jj_scan_token(127)) return true;
    return false;
  }

  final private boolean jj_3R_127() {
    if (jj_3R_138()) return true;
    return false;
  }

  final private boolean jj_3_15() {
    if (jj_scan_token(K_COUNT)) return true;
    if (jj_scan_token(125)) return true;
    if (jj_scan_token(140)) return true;
    if (jj_scan_token(127)) return true;
    return false;
  }

  final private boolean jj_3R_106() {
    if (jj_scan_token(K_AND)) return true;
    if (jj_3R_105()) return true;
    return false;
  }

  final private boolean jj_3R_91() {
    if (jj_3R_26()) return true;
    return false;
  }

  final private boolean jj_3R_188() {
    if (jj_scan_token(126)) return true;
    if (jj_3R_98()) return true;
    return false;
  }

  final private boolean jj_3R_101() {
    if (jj_3R_105()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_106()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_80() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_90()) {
    jj_scanpos = xsp;
    if (jj_3R_91()) {
    jj_scanpos = xsp;
    if (jj_3_15()) {
    jj_scanpos = xsp;
    if (jj_3_16()) {
    jj_scanpos = xsp;
    if (jj_3_17()) {
    jj_scanpos = xsp;
    if (jj_3R_92()) {
    jj_scanpos = xsp;
    if (jj_3R_93()) {
    jj_scanpos = xsp;
    if (jj_3R_94()) {
    jj_scanpos = xsp;
    if (jj_3R_95()) {
    jj_scanpos = xsp;
    if (jj_3R_96()) return true;
    }
    }
    }
    }
    }
    }
    }
    }
    }
    return false;
  }

  final private boolean jj_3R_90() {
    if (jj_scan_token(K_NULL)) return true;
    return false;
  }

  final private boolean jj_3R_181() {
    if (jj_3R_98()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_188()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_149() {
    if (jj_scan_token(125)) return true;
    if (jj_3R_114()) return true;
    if (jj_scan_token(127)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_172()) jj_scanpos = xsp;
    if (jj_3R_173()) return true;
    return false;
  }

  final private boolean jj_3R_135() {
    if (jj_scan_token(126)) return true;
    if (jj_3R_134()) return true;
    return false;
  }

  final private boolean jj_3R_67() {
    if (jj_scan_token(147)) return true;
    if (jj_3R_66()) return true;
    return false;
  }

  final private boolean jj_3R_170() {
    if (jj_3R_176()) return true;
    return false;
  }

  final private boolean jj_3_5() {
    if (jj_3R_18()) return true;
    return false;
  }

  final private boolean jj_3R_175() {
    if (jj_3R_173()) return true;
    return false;
  }

  final private boolean jj_3R_134() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_5()) {
    jj_scanpos = xsp;
    if (jj_3R_148()) {
    jj_scanpos = xsp;
    if (jj_3R_149()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3R_102() {
    if (jj_scan_token(K_OR)) return true;
    if (jj_3R_101()) return true;
    return false;
  }

  final private boolean jj_3R_55() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_68()) {
    jj_scanpos = xsp;
    if (jj_3R_69()) return true;
    }
    return false;
  }

  final private boolean jj_3R_68() {
    if (jj_scan_token(140)) return true;
    if (jj_3R_54()) return true;
    return false;
  }

  final private boolean jj_3R_103() {
    if (jj_scan_token(130)) return true;
    if (jj_3R_17()) return true;
    return false;
  }

  final private boolean jj_3R_100() {
    if (jj_scan_token(130)) return true;
    if (jj_3R_17()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_103()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_126() {
    if (jj_3R_137()) return true;
    return false;
  }

  final private boolean jj_3R_157() {
    if (jj_3R_118()) return true;
    return false;
  }

  final private boolean jj_3R_99() {
    if (jj_3R_101()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_102()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3_4() {
    if (jj_3R_17()) return true;
    if (jj_scan_token(130)) return true;
    if (jj_3R_17()) return true;
    if (jj_scan_token(141)) return true;
    return false;
  }

  final private boolean jj_3R_98() {
    if (jj_3R_17()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_100()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_89() {
    if (jj_scan_token(139)) return true;
    return false;
  }

  final private boolean jj_3R_79() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(138)) {
    jj_scanpos = xsp;
    if (jj_3R_89()) return true;
    }
    return false;
  }

  final private boolean jj_3R_66() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_79()) jj_scanpos = xsp;
    if (jj_3R_80()) return true;
    return false;
  }

  final private boolean jj_3R_124() {
    if (jj_scan_token(K_FROM)) return true;
    if (jj_3R_134()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_135()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_56() {
    if (jj_scan_token(138)) return true;
    if (jj_3R_33()) return true;
    return false;
  }

  final private boolean jj_3R_34() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_56()) {
    jj_scanpos = xsp;
    if (jj_3R_57()) {
    jj_scanpos = xsp;
    if (jj_3R_58()) return true;
    }
    }
    return false;
  }

  final private boolean jj_3_11() {
    if (jj_3R_23()) return true;
    return false;
  }

  final private boolean jj_3R_169() {
    if (jj_3R_21()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_175()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_151() {
    if (jj_scan_token(K_START)) return true;
    if (jj_scan_token(K_WITH)) return true;
    if (jj_3R_99()) return true;
    return false;
  }

  final private boolean jj_3R_54() {
    if (jj_3R_66()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_67()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3_3() {
    if (jj_3R_17()) return true;
    if (jj_scan_token(141)) return true;
    return false;
  }

  final private boolean jj_3R_152() {
    if (jj_scan_token(K_HAVING)) return true;
    if (jj_3R_99()) return true;
    return false;
  }

  final private boolean jj_3R_16() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3_3()) {
    jj_scanpos = xsp;
    if (jj_3_4()) return true;
    }
    return false;
  }

  final private boolean jj_3R_69() {
    if (jj_scan_token(146)) return true;
    if (jj_3R_54()) return true;
    return false;
  }

  final private boolean jj_3_7() {
    if (jj_scan_token(125)) return true;
    return false;
  }

  final private boolean jj_3R_33() {
    if (jj_3R_54()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_55()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_173() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(8)) jj_scanpos = xsp;
    if (jj_scan_token(S_IDENTIFIER)) return true;
    return false;
  }

  final private boolean jj_3R_156() {
    if (jj_scan_token(125)) return true;
    if (jj_3R_118()) return true;
    if (jj_scan_token(127)) return true;
    return false;
  }

  final private boolean jj_3R_125() {
    if (jj_3R_136()) return true;
    return false;
  }

  final private boolean jj_3R_174() {
    if (jj_scan_token(K_ALL)) return true;
    return false;
  }

  final private boolean jj_3R_155() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(59)) {
    jj_scanpos = xsp;
    if (jj_scan_token(31)) return true;
    }
    return false;
  }

  final private boolean jj_3R_154() {
    if (jj_scan_token(K_INTERSECT)) return true;
    return false;
  }

  final private boolean jj_3_2() {
    if (jj_3R_16()) return true;
    return false;
  }

  final private boolean jj_3R_147() {
    if (jj_scan_token(126)) return true;
    if (jj_3R_146()) return true;
    return false;
  }

  final private boolean jj_3R_153() {
    if (jj_scan_token(K_UNION)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_174()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_139() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_153()) {
    jj_scanpos = xsp;
    if (jj_3R_154()) {
    jj_scanpos = xsp;
    if (jj_3R_155()) return true;
    }
    }
    xsp = jj_scanpos;
    if (jj_3R_156()) {
    jj_scanpos = xsp;
    if (jj_3R_157()) return true;
    }
    return false;
  }

  final private boolean jj_3R_58() {
    if (jj_scan_token(145)) return true;
    if (jj_3R_33()) return true;
    return false;
  }

  final private boolean jj_3R_168() {
    if (jj_3R_16()) return true;
    return false;
  }

  final private boolean jj_3R_57() {
    if (jj_scan_token(139)) return true;
    if (jj_3R_33()) return true;
    return false;
  }

  final private boolean jj_3R_146() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_168()) {
    jj_scanpos = xsp;
    if (jj_3R_169()) return true;
    }
    return false;
  }

  final private boolean jj_3R_21() {
    if (jj_3R_33()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_34()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_61() {
    if (jj_scan_token(130)) return true;
    if (jj_3R_17()) return true;
    return false;
  }

  final private boolean jj_3_1() {
    Token xsp;
    if (jj_scan_token(125)) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_scan_token(125)) { jj_scanpos = xsp; break; }
    }
    if (jj_scan_token(K_SELECT)) return true;
    return false;
  }

  final private boolean jj_3R_145() {
    if (jj_scan_token(K_NOT)) return true;
    return false;
  }

  final private boolean jj_3R_138() {
    if (jj_scan_token(K_GROUP)) return true;
    if (jj_scan_token(K_BY)) return true;
    if (jj_3R_104()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_152()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_133() {
    if (jj_3R_146()) return true;
    Token xsp;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_147()) { jj_scanpos = xsp; break; }
    }
    return false;
  }

  final private boolean jj_3R_130() {
    if (jj_scan_token(K_IS)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_145()) jj_scanpos = xsp;
    if (jj_scan_token(K_NULL)) return true;
    return false;
  }

  final private boolean jj_3R_123() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_132()) {
    jj_scanpos = xsp;
    if (jj_3R_133()) return true;
    }
    return false;
  }

  final private boolean jj_3R_132() {
    if (jj_scan_token(140)) return true;
    return false;
  }

  final private boolean jj_3R_37() {
    if (jj_scan_token(130)) return true;
    if (jj_3R_17()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_61()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3_10() {
    if (jj_3R_22()) return true;
    return false;
  }

  final private boolean jj_3R_114() {
    if (jj_3R_118()) return true;
    return false;
  }

  final private boolean jj_3R_150() {
    if (jj_scan_token(K_START)) return true;
    if (jj_scan_token(K_WITH)) return true;
    if (jj_3R_99()) return true;
    return false;
  }

  final private boolean jj_3R_137() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_150()) jj_scanpos = xsp;
    if (jj_scan_token(K_CONNECT)) return true;
    if (jj_scan_token(K_BY)) return true;
    if (jj_3R_99()) return true;
    xsp = jj_scanpos;
    if (jj_3R_151()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_24() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(62)) jj_scanpos = xsp;
    if (jj_scan_token(K_LIKE)) return true;
    if (jj_3R_36()) return true;
    return false;
  }

  final private boolean jj_3R_128() {
    if (jj_3R_139()) return true;
    return false;
  }

  final private boolean jj_3R_26() {
    if (jj_3R_17()) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_37()) jj_scanpos = xsp;
    if (jj_scan_token(125)) return true;
    if (jj_scan_token(138)) return true;
    if (jj_scan_token(127)) return true;
    return false;
  }

  final private boolean jj_3R_60() {
    if (jj_3R_70()) return true;
    return false;
  }

  final private boolean jj_3R_131() {
    if (jj_scan_token(K_DISTINCT)) return true;
    return false;
  }

  final private boolean jj_3R_136() {
    if (jj_scan_token(K_WHERE)) return true;
    if (jj_3R_99()) return true;
    return false;
  }

  final private boolean jj_3R_23() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(62)) jj_scanpos = xsp;
    if (jj_scan_token(K_BETWEEN)) return true;
    if (jj_3R_36()) return true;
    if (jj_scan_token(K_AND)) return true;
    if (jj_3R_36()) return true;
    return false;
  }

  final private boolean jj_3R_122() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(5)) {
    jj_scanpos = xsp;
    if (jj_3R_131()) return true;
    }
    return false;
  }

  final private boolean jj_3R_143() {
    if (jj_3R_104()) return true;
    return false;
  }

  final private boolean jj_3R_111() {
    if (jj_scan_token(K_WHEN)) return true;
    if (jj_3R_21()) return true;
    if (jj_scan_token(K_THEN)) return true;
    if (jj_3R_21()) return true;
    return false;
  }

  final private boolean jj_3R_113() {
    if (jj_scan_token(K_ELSE)) return true;
    if (jj_3R_21()) return true;
    return false;
  }

  final private boolean jj_3R_144() {
    if (jj_3R_114()) return true;
    return false;
  }

  final private boolean jj_3R_31() {
    if (jj_scan_token(125)) return true;
    if (jj_3R_18()) return true;
    if (jj_scan_token(127)) return true;
    return false;
  }

  final private boolean jj_3R_118() {
    if (jj_scan_token(K_SELECT)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_122()) jj_scanpos = xsp;
    if (jj_3R_123()) return true;
    if (jj_3R_124()) return true;
    xsp = jj_scanpos;
    if (jj_3R_125()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_126()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_127()) jj_scanpos = xsp;
    xsp = jj_scanpos;
    if (jj_3R_128()) jj_scanpos = xsp;
    return false;
  }

  final private boolean jj_3R_97() {
    if (jj_scan_token(K_WHEN)) return true;
    if (jj_3R_99()) return true;
    if (jj_scan_token(K_THEN)) return true;
    if (jj_3R_21()) return true;
    return false;
  }

  final private boolean jj_3R_82() {
    Token xsp;
    if (jj_3R_97()) return true;
    while (true) {
      xsp = jj_scanpos;
      if (jj_3R_97()) { jj_scanpos = xsp; break; }
    }
    xsp = jj_scanpos;
    if (jj_3R_113()) jj_scanpos = xsp;
    if (jj_scan_token(K_END)) return true;
    return false;
  }

  final private boolean jj_3R_35() {
    if (jj_scan_token(K_NOT)) return true;
    return false;
  }

  final private boolean jj_3R_22() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_35()) jj_scanpos = xsp;
    if (jj_scan_token(K_IN)) return true;
    if (jj_scan_token(125)) return true;
    xsp = jj_scanpos;
    if (jj_3R_143()) {
    jj_scanpos = xsp;
    if (jj_3R_144()) return true;
    }
    if (jj_scan_token(127)) return true;
    return false;
  }

  final private boolean jj_3R_166() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_scan_token(5)) {
    jj_scanpos = xsp;
    if (jj_scan_token(7)) return true;
    }
    return false;
  }

  final private boolean jj_3R_72() {
    if (jj_3R_82()) return true;
    return false;
  }

  final private boolean jj_3R_52() {
    if (jj_scan_token(K_NATURAL)) return true;
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_64()) jj_scanpos = xsp;
    if (jj_scan_token(K_JOIN)) return true;
    if (jj_3R_50()) return true;
    return false;
  }

  final private boolean jj_3R_186() {
    if (jj_scan_token(K_ON)) return true;
    if (jj_3R_99()) return true;
    return false;
  }

  final private boolean jj_3R_180() {
    Token xsp;
    xsp = jj_scanpos;
    if (jj_3R_186()) {
    jj_scanpos = xsp;
    if (jj_3R_187()) return true;
    }
    return false;
  }

  final private boolean jj_3R_112() {
    if (jj_scan_token(K_ELSE)) return true;
    if (jj_3R_21()) return true;
    return false;
  }

  final private boolean jj_3R_25() {
    if (jj_scan_token(125)) return true;
    if (jj_scan_token(K_SELECT)) return true;
    return false;
  }

  public CqlParserTokenManager token_source;
  JavaCharStream jj_input_stream;
  public Token token, jj_nt;
  private int jj_ntk;
  private Token jj_scanpos, jj_lastpos;
  private int jj_la;
  public boolean lookingAhead = false;
  private boolean jj_semLA;
  private int jj_gen;
  final private int[] jj_la1 = new int[131];
  static private int[] jj_la1_0;
  static private int[] jj_la1_1;
  static private int[] jj_la1_2;
  static private int[] jj_la1_3;
  static private int[] jj_la1_4;
  static {
      jj_la1_0();
      jj_la1_1();
      jj_la1_2();
      jj_la1_3();
      jj_la1_4();
   }
   private static void jj_la1_0() {
      jj_la1_0 = new int[] {0x10000,0x0,0x0,0x413000,0x12040000,0x0,0x12040000,0x0,0x20000,0x0,0x0,0x0,0x20000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x108000,0x0,0x0,0x0,0x0,0x10000000,0x10000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000020,0x8000020,0x0,0x80000,0x0,0x80000000,0x0,0x108000,0x100,0x108000,0x100,0x0,0x0,0x100,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1800000,0x1800000,0x1800000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x200000,0x0,0x0,0x0,0x0,0x20,0x80000000,0x80000000,0x0,0x4000200,0x4000200,0x0,0x4000200,0x4000200,0x0,0x0,0x40,0x0,0x108000,0x0,0x0,0x108000,0x0,0x0,0x800,0x0,0xa0,0xa0,0x0,0x108000,0x108000,0x0,0x108000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x8000020,0x0,0x0,0x100000,0x108000,0x108000,0x0,0x20000000,0x0,0x20000000,0x0,0x0,};
   }
   private static void jj_la1_1() {
      jj_la1_1 = new int[] {0x20004008,0x0,0x0,0x20004008,0x442004,0x4,0x442004,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1,0x0,0x0,0x1,0x0,0x0,0x41800002,0x0,0x0,0x20,0x0,0x40000,0x40000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x0,0x0,0x0,0x0,0x80,0x8008000,0x0,0x1800000,0x0,0x1800000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80000000,0x0,0x80000000,0x0,0x0,0x6000000,0x300,0x0,0x6000300,0x6000300,0x100040,0x0,0x101040,0x101040,0x100040,0x0,0x101040,0x101040,0x0,0x0,0x20181040,0x0,0x0,0x0,0x400,0x0,0x8000000,0x8008000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x40000000,0x41800000,0x40000000,0x0,0x1800000,0x0,0x20000,0x40220800,0x0,0x0,0x0,0x0,0x1800000,0x1800000,0x40000000,0x1800000,0x40000000,0x40000000,0x40000000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x1800000,0x1800000,0x1800000,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_2() {
      jj_la1_2 = new int[] {0x4004,0x0,0x0,0x4004,0x1920800,0x800,0x1920800,0x0,0x0,0x0,0x1,0x0,0x0,0x20,0x2000000,0x40000,0x40000,0x2040000,0x0,0x0,0xb0000402,0x0,0x800000,0x0,0x0,0x900000,0x100000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x80,0x0,0x0,0x0,0x0,0x8000000,0x0,0x0,0x0,0xb0000002,0x0,0xb0000002,0x0,0x0,0x0,0x0,0x0,0x0,0x200,0x0,0x1000,0x0,0x81000,0x40008000,0x600000,0x0,0x0,0x0,0x600000,0x600000,0x10000,0x100,0x10000,0x10000,0x10000,0x100,0x10000,0x10000,0x10,0x10,0x10000,0x0,0x8000000,0x8000000,0x0,0x0,0x0,0x0,0x800000,0x0,0x0,0x0,0x0,0x0,0x8,0x40,0x0,0x0,0xb0000402,0x0,0x400,0xb0000402,0x0,0x0,0x0,0x0,0x0,0x0,0x400,0xb0000402,0xb0000002,0x0,0xb0800002,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x2,0x0,0xb0000000,0xb0000000,0xb0000002,0x0,0x0,0x0,0x0,0x0,0x0,};
   }
   private static void jj_la1_3() {
      jj_la1_3 = new int[] {0x300,0x40000000,0x20000000,0x300,0x20,0x0,0x20,0x8000,0x0,0x40000000,0x0,0x8000,0x0,0x10000,0x0,0x20,0x20,0x0,0x2000,0x40000000,0x3c820c00,0x20000000,0x80,0x0,0x2000,0x0,0x0,0x0,0x0,0x40000000,0x10800000,0x0,0x0,0x0,0x0,0x820000,0x0,0x0,0x0,0x0,0x2000,0x0,0x0,0x10,0x40000000,0x3c820c00,0x800000,0x3c820c00,0x0,0x40000000,0x0,0x800000,0x0,0x30800000,0x0,0x20008,0x0,0x20008,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x10,0x10,0x0,0x0,0x10,0x10,0x40,0x40,0x10,0x30800000,0x0,0x0,0x0,0x0,0x0,0x10,0x0,0x0,0x0,0x40000000,0x0,0x0,0x0,0x0,0x0,0x0,0x3c820c00,0x0,0x0,0x3c820c00,0x0,0x0,0x0,0x40000000,0x0,0x0,0x0,0x3c820c00,0x3c820c00,0x0,0x3c820c00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x3c820000,0xc00,0x800c00,0x3c821c00,0x1000,0x0,0x1000,0x0,0x0,0x0,};
   }
   private static void jj_la1_4() {
      jj_la1_4 = new int[] {0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x110c00,0x0,0x0,0x0,0x0,0x0,0x0,0x4,0x4,0x0,0x0,0x3fa,0x4,0xc00,0xc00,0xc00,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x101c00,0x0,0x100c00,0x0,0x0,0x4000,0x0,0x4000,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x100c00,0x0,0x0,0x100c00,0x3fa,0x0,0x3fa,0x0,0x0,0x0,0x0,0x110c00,0x110c00,0x0,0x110c00,0x0,0x0,0x0,0x20c00,0x20c00,0x41000,0x41000,0x80000,0xc00,0xc00,0x0,0x0,0x0,0x100000,0x100000,0x100c00,0x0,0x0,0x0,0x0,0x4,0x4,};
   }
  final private JJCalls[] jj_2_rtns = new JJCalls[17];
  private boolean jj_rescan = false;
  private int jj_gc = 0;

  public CqlParser(java.io.InputStream stream) {
     this(stream, null);
  }
  public CqlParser(java.io.InputStream stream, String encoding) {
    try { jj_input_stream = new JavaCharStream(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source = new CqlParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 131; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.InputStream stream) {
     ReInit(stream, null);
  }
  public void ReInit(java.io.InputStream stream, String encoding) {
    try { jj_input_stream.ReInit(stream, encoding, 1, 1); } catch(java.io.UnsupportedEncodingException e) { throw new RuntimeException(e); }
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 131; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public CqlParser(java.io.Reader stream) {
    jj_input_stream = new JavaCharStream(stream, 1, 1);
    token_source = new CqlParserTokenManager(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 131; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(java.io.Reader stream) {
    jj_input_stream.ReInit(stream, 1, 1);
    token_source.ReInit(jj_input_stream);
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 131; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public CqlParser(CqlParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 131; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  public void ReInit(CqlParserTokenManager tm) {
    token_source = tm;
    token = new Token();
    jj_ntk = -1;
    jj_gen = 0;
    for (int i = 0; i < 131; i++) jj_la1[i] = -1;
    for (int i = 0; i < jj_2_rtns.length; i++) jj_2_rtns[i] = new JJCalls();
  }

  final private Token jj_consume_token(int kind) throws ParseException {
    Token oldToken;
    if ((oldToken = token).next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    if (token.kind == kind) {
      jj_gen++;
      if (++jj_gc > 100) {
        jj_gc = 0;
        for (int i = 0; i < jj_2_rtns.length; i++) {
          JJCalls c = jj_2_rtns[i];
          while (c != null) {
            if (c.gen < jj_gen) c.first = null;
            c = c.next;
          }
        }
      }
      return token;
    }
    token = oldToken;
    jj_kind = kind;
    throw generateParseException();
  }

  static private final class LookaheadSuccess extends java.lang.Error { }
  final private LookaheadSuccess jj_ls = new LookaheadSuccess();
  final private boolean jj_scan_token(int kind) {
    if (jj_scanpos == jj_lastpos) {
      jj_la--;
      if (jj_scanpos.next == null) {
        jj_lastpos = jj_scanpos = jj_scanpos.next = token_source.getNextToken();
      } else {
        jj_lastpos = jj_scanpos = jj_scanpos.next;
      }
    } else {
      jj_scanpos = jj_scanpos.next;
    }
    if (jj_rescan) {
      int i = 0; Token tok = token;
      while (tok != null && tok != jj_scanpos) { i++; tok = tok.next; }
      if (tok != null) jj_add_error_token(kind, i);
    }
    if (jj_scanpos.kind != kind) return true;
    if (jj_la == 0 && jj_scanpos == jj_lastpos) throw jj_ls;
    return false;
  }

  final public Token getNextToken() {
    if (token.next != null) token = token.next;
    else token = token.next = token_source.getNextToken();
    jj_ntk = -1;
    jj_gen++;
    return token;
  }

  final public Token getToken(int index) {
    Token t = lookingAhead ? jj_scanpos : token;
    for (int i = 0; i < index; i++) {
      if (t.next != null) t = t.next;
      else t = t.next = token_source.getNextToken();
    }
    return t;
  }

  final private int jj_ntk() {
    if ((jj_nt=token.next) == null)
      return (jj_ntk = (token.next=token_source.getNextToken()).kind);
    else
      return (jj_ntk = jj_nt.kind);
  }

  private java.util.Vector<int[]> jj_expentries = new java.util.Vector<int[]>();
  private int[] jj_expentry;
  private int jj_kind = -1;
  private int[] jj_lasttokens = new int[100];
  private int jj_endpos;

  private void jj_add_error_token(int kind, int pos) {
    if (pos >= 100) return;
    if (pos == jj_endpos + 1) {
      jj_lasttokens[jj_endpos++] = kind;
    } else if (jj_endpos != 0) {
      jj_expentry = new int[jj_endpos];
      for (int i = 0; i < jj_endpos; i++) {
        jj_expentry[i] = jj_lasttokens[i];
      }
      boolean exists = false;
      for (java.util.Enumeration e = jj_expentries.elements(); e.hasMoreElements();) {
        int[] oldentry = (int[])(e.nextElement());
        if (oldentry.length == jj_expentry.length) {
          exists = true;
          for (int i = 0; i < jj_expentry.length; i++) {
            if (oldentry[i] != jj_expentry[i]) {
              exists = false;
              break;
            }
          }
          if (exists) break;
        }
      }
      if (!exists) jj_expentries.addElement(jj_expentry);
      if (pos != 0) jj_lasttokens[(jj_endpos = pos) - 1] = kind;
    }
  }

  public ParseException generateParseException() {
    jj_expentries.removeAllElements();
    boolean[] la1tokens = new boolean[149];
    for (int i = 0; i < 149; i++) {
      la1tokens[i] = false;
    }
    if (jj_kind >= 0) {
      la1tokens[jj_kind] = true;
      jj_kind = -1;
    }
    for (int i = 0; i < 131; i++) {
      if (jj_la1[i] == jj_gen) {
        for (int j = 0; j < 32; j++) {
          if ((jj_la1_0[i] & (1<<j)) != 0) {
            la1tokens[j] = true;
          }
          if ((jj_la1_1[i] & (1<<j)) != 0) {
            la1tokens[32+j] = true;
          }
          if ((jj_la1_2[i] & (1<<j)) != 0) {
            la1tokens[64+j] = true;
          }
          if ((jj_la1_3[i] & (1<<j)) != 0) {
            la1tokens[96+j] = true;
          }
          if ((jj_la1_4[i] & (1<<j)) != 0) {
            la1tokens[128+j] = true;
          }
        }
      }
    }
    for (int i = 0; i < 149; i++) {
      if (la1tokens[i]) {
        jj_expentry = new int[1];
        jj_expentry[0] = i;
        jj_expentries.addElement(jj_expentry);
      }
    }
    jj_endpos = 0;
    jj_rescan_token();
    jj_add_error_token(0, 0);
    int[][] exptokseq = new int[jj_expentries.size()][];
    for (int i = 0; i < jj_expentries.size(); i++) {
      exptokseq[i] = (int[])jj_expentries.elementAt(i);
    }
    return new ParseException(token, exptokseq, tokenImage);
  }

  final public void enable_tracing() {
  }

  final public void disable_tracing() {
  }

  final private void jj_rescan_token() {
    jj_rescan = true;
    for (int i = 0; i < 17; i++) {
    try {
      JJCalls p = jj_2_rtns[i];
      do {
        if (p.gen > jj_gen) {
          jj_la = p.arg; jj_lastpos = jj_scanpos = p.first;
          switch (i) {
            case 0: jj_3_1(); break;
            case 1: jj_3_2(); break;
            case 2: jj_3_3(); break;
            case 3: jj_3_4(); break;
            case 4: jj_3_5(); break;
            case 5: jj_3_6(); break;
            case 6: jj_3_7(); break;
            case 7: jj_3_8(); break;
            case 8: jj_3_9(); break;
            case 9: jj_3_10(); break;
            case 10: jj_3_11(); break;
            case 11: jj_3_12(); break;
            case 12: jj_3_13(); break;
            case 13: jj_3_14(); break;
            case 14: jj_3_15(); break;
            case 15: jj_3_16(); break;
            case 16: jj_3_17(); break;
          }
        }
        p = p.next;
      } while (p != null);
      } catch(LookaheadSuccess ls) { }
    }
    jj_rescan = false;
  }

  final private void jj_save(int index, int xla) {
    JJCalls p = jj_2_rtns[index];
    while (p.gen > jj_gen) {
      if (p.next == null) { p = p.next = new JJCalls(); break; }
      p = p.next;
    }
    p.gen = jj_gen + xla - jj_la; p.first = token; p.arg = xla;
  }

  static final class JJCalls {
    int gen;
    Token first;
    int arg;
    JJCalls next;
  }

}
