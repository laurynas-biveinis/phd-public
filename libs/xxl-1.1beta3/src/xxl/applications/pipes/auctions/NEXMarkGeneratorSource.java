/* XXL: The eXtensible and fleXible Library for data processing

Copyright (C) 2000-2006 Prof. Dr. Bernhard Seeger
                        Head of the Database Research Group
                        Department of Mathematics and Computer Science
                        University of Marburg
                        Germany

This library is free software; you can redistribute it and/or
modify it under the terms of the GNU Lesser General Public
License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.

This library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307,
USA

	http://www.xxl-library.de

bugs, requests for enhancements: request@xxl-library.de

If you want to be informed on new versions of XXL you can 
subscribe to our mailing-list. Send an email to 
	
	xxl-request@lists.uni-marburg.de

without subject and the word "subscribe" in the message body. 
*/

package xxl.applications.pipes.auctions;

import java.io.BufferedWriter;
import java.io.DataInput;
import java.io.DataOutput;
import java.io.EOFException;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Reader;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.HashMap;
import java.util.Iterator;
import java.util.NoSuchElementException;
import java.util.Random;

import org.exolab.castor.mapping.Mapping;
import org.exolab.castor.xml.Marshaller;
import org.exolab.castor.xml.Unmarshaller;

import xxl.applications.pipes.auctions.mapping.Bidder;
import xxl.applications.pipes.auctions.mapping.OpenAuction;
import xxl.applications.pipes.auctions.mapping.OpenAuctions;
import xxl.applications.pipes.auctions.mapping.People;
import xxl.applications.pipes.auctions.mapping.Site;
import xxl.core.collections.queues.DynamicHeap;
import xxl.core.cursors.AbstractCursor;
import xxl.core.cursors.Cursor;
import xxl.core.cursors.sources.io.FileInputCursor;
import xxl.core.functions.Function;
import xxl.core.io.converters.Converter;
import xxl.core.pipes.elements.TemporalObject;
import xxl.core.pipes.elements.TimeInterval;
import xxl.core.pipes.processors.SourceProcessor;
import xxl.core.pipes.sinks.VisualSink;
import xxl.core.pipes.sources.AbstractSource;
import xxl.core.util.metaData.CompositeMetaData;
import xxl.core.util.timers.Timer;
import xxl.core.util.timers.TimerUtils;

/**
 * This class connects data generated by the NEXMark generator to PIPES. The original
 * NEXMark generator has been modified to generate three files (person.xml, auction.xml & bid.xml).
 * (see xxl.applications.pipes.auctions.nexmark) <br>
 * The first file can be connected, by calling the static getPersonCursor method, resulting
 * in a cursor that delivers an instance of 'Person' per call. <br>
 * The latter two can be used by using the constructor. This constructs a Source, that delivers
 * OpenAuction instances <br>
 * Because the mapping from xml to java is done by castor, a mapping file is required. It is
 * the same for all three (xxl.applications.pipes.auctions.mapping.NEXMark-mapping.xml) <br>
 * Note, that prettyprint MUST be activated during file generation in the NEXMark generator.  
 */
public class NEXMarkGeneratorSource extends AbstractSource {

	/**
	 * A constant, signing, that the type of the input stream is an auction stream.
	 */	
	public final static int OPEN_AUCTION_STREAM = 1;
	
	/**
	 * A constant, signing, that the type of the input stream is an auction stream.
	 */	
	public final static int CLOSED_AUCTION_STREAM = 2;	
	
	/**
	 * A constant, signing, that the type of the input stream is a bid stream.
	 */	
	public final static int BID_STREAM = 3;	
	
	/**
	 * Creates a converter, that accepts input from the modified NEXMarkgenerator
	 * and puts it into a Site Object.
	 */
	public static class NexMarkConverter extends Converter {
		
		/**
		 * A map for castor to map xml to java objects (NEXMark-mapping.xml).
		 */
		protected String map;
		
		/**
		 * The path to the underlying file.
		 */
		protected String filename;
		
		protected BufferedWriter writer;
		
		public NexMarkConverter(String map, String filename) {		
			this.map = map;
			this.filename = filename;
			
		}
		public NexMarkConverter(String map) {
			this(map, null);
		}
		
		public Object read(DataInput dataInput, Object object) throws IOException {
			StringBuffer sb = new StringBuffer();
			String s = new String();
			do {
				s = dataInput.readLine();
				if (s == null) throw new EOFException();
				sb.append(s);
			} while ( !(s.startsWith("</site>")) && !(s.endsWith("</site>")));
			
			Mapping mapping = new Mapping();
			try {
				mapping.loadMapping(map);
			} catch (Exception e) {
				e.printStackTrace();
			}
			
			Reader castorInput = new StringReader(sb.toString());
			Unmarshaller um = null;
			Site site = null;		
			try {
				um = new Unmarshaller(mapping);
				site = (Site) um.unmarshal(castorInput);
			} catch (Exception e1) {		 
				e1.printStackTrace();
			}  
			return site;
		}

		public void write(DataOutput dataOutput, Object object) throws IOException {
			if (filename == null)
				throw new IllegalStateException("set a filename with the two paramenter constructor");
			Mapping mapping = new Mapping();
			try {
				mapping.loadMapping(map);									
				Marshaller marshaller = new Marshaller(new BufferedWriter(new FileWriter(filename), 500000));
				marshaller.setSuppressXSIType(true);
				marshaller.setMapping(mapping);
				marshaller.marshal(object);
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
		
		public void append(Object object) {
			if (filename == null)
				throw new IllegalStateException("set a filename with the two paramenter constructor");
			Mapping mapping = new Mapping();
			try {
				if (writer == null)
					writer = new BufferedWriter(new FileWriter(filename), 500000);
				mapping.loadMapping(map);									
				Marshaller marshaller = new Marshaller(writer);
				marshaller.setSuppressXSIType(true);
				marshaller.setMapping(mapping);
				marshaller.marshal(object);			
				writer.newLine();
			} catch (Exception e) {
				e.printStackTrace();
			}
		}
	}
	
	/**
	 * Returns a cursor, that delivers 'Person' instances for each person element generated by the
	 * modified NEXMark generator. 
	 * @param sourceFile the modified sourcefile generated by castor. an incompatible type will result in
	 * a nullpointer or classcast exception.
	 * @param mapFile a file, that is required to map xml to java objects with castor. use
	 * xxl.applications.pipes.auctions.mapping.NEXMark-mapping.xml
	 * @return a cursor, that delivers 'Person' instances for each person element generated by the
	 * NEXMark generator. 
	 */
	public static Cursor getPersonCursor(final String sourceFile, final String mapFile) {
		return new AbstractCursor() {			
			Cursor cursor = new FileInputCursor(new NexMarkConverter(mapFile), new File(sourceFile));
			Site site;
			int peopleIndex =0;

			protected boolean hasNextObject() {
				if (peopleIndex > 0){					
					if (site.getPeople().size() > peopleIndex)
						return true;
					peopleIndex = 0;
				}
				while ( peopleIndex==0 && cursor.hasNext()) {
					site = (Site)cursor.next();
					if (site.getPeople().size() > 0)
						return true;				
				}
				return false;
			}
			
			protected Object nextObject() {				
				return ((People)site.getPeople().get(peopleIndex++)).getPerson();
			}
			
			public void close() {				
				super.close();
				cursor.close();
			}
		};				
	}
	
	/**
	 * Returns a cursor that delivers bids.
	 * @param sourceFile the sourfile (bid.xml)
	 * @param mapFile a map for castor to map xml to java objects (NEXMark-mapping.xml).
	 * @return a cursor that delivers bid data.
	 */
	public static Cursor getBidCursor(final String sourceFile, final String mapFile) {
		return new AbstractCursor() {
			Cursor cursor = new FileInputCursor(new NexMarkConverter(mapFile), new File(sourceFile));
			Site site;
			int bidIndex =0;
			Function transformation = GET_PRICE_FUNCTION();

			protected boolean hasNextObject() {
				if (bidIndex > 0){					
					if (((OpenAuctions)site.getOpenAuctions().get(0)).getOpenAuction().size() > bidIndex)
						return true;
					bidIndex = 0;
				}
				while ( bidIndex==0 && cursor.hasNext()) {
					site = (Site)cursor.next();
					if (site.getOpenAuctions().size() > 0 && ((OpenAuctions)site.getOpenAuctions().get(0)).getOpenAuction().size() > 0)
						return true;				
				}
				return false;
			}
			
			protected Object nextObject() {
				return transformation.invoke(((OpenAuctions)site.getOpenAuctions().get(0)).getOpenAuction().get(bidIndex++));
			}
			
			public void close() {				
				super.close();
				cursor.close();
			}
		};
	}
	
	/**
	 * Returns a cursor that delivers bids.
	 * @param sourceFile the sourfile (auction.xml or closedauction.xml)
	 * @param mapFile a map for castor to map xml to java objects (NEXMark-mapping.xml).
	 * @return a cursor that delivers the auction data.
	 */
	public static Cursor getAuctionCursor(final String sourceFile, final String mapFile) {
		return new AbstractCursor(){			
			Cursor cursor = new FileInputCursor(new NexMarkConverter(mapFile), new File(sourceFile), 20000000);
			Site site;
			int auctionsIndex = 0;
			int auctionIndex = 0;
			Function transformation = null;

			protected boolean hasNextObject() {
				if ((site != null) && ((OpenAuctions)site.getOpenAuctions().get(auctionsIndex)).getOpenAuction().size() > auctionIndex) {
					return true;
				}
				else if ((site != null) && site.getOpenAuctions().size() > auctionsIndex+1){
					auctionIndex=0;
					auctionsIndex++;
					return true;
				}
				else {
					do {
						if (! cursor.hasNext()) {							
							return false;					
						}					
						site = (Site) cursor.next();
					}
					while (site.getOpenAuctions().size() ==0 || ((OpenAuctions)site.getOpenAuctions().get(0)).getOpenAuction().size() == 0);
					auctionIndex=0;
					auctionsIndex=0;
					return true;
				}			
			}

			protected Object nextObject() {				
				return ((OpenAuctions)site.getOpenAuctions().get(auctionsIndex)).getOpenAuction().get(auctionIndex++);				
			}
			
			public void close() {				
				super.close();
				cursor.close();
			}
		};
	}
	
	/**
	 * Returns a function, that transforms the content of a TemporalstampedObject
	 * from xxl.applications.pipes.auction.nexmark.mapping.OpenAuction to  
	 * xxl.applications.pipes.auction.Bid.
	 * @return the function
	 */
	public final static Function GET_BID_FUNCTION() {
		return new Function(){
			public Object invoke(Object object) {
			    OpenAuction oa = (OpenAuction)((TemporalObject)object).getObject();
			    Bidder b = (Bidder)oa.getBidder().get(0);
				Bid bid = new Bid();
				bid.setBid(b.getBid());
				bid.setItemID(oa.getId());
				bid.setBidderID(b.getPerson_ref().getPerson());
				bid.setTimestamp(b.getTime());				
				return new TemporalObject(bid, new TimeInterval(b.getTime(), TimeInterval.INFINITY));
			}
		};
	}
	
	/**
	 * Returns a function, that transforms the content of a TimestampedObject
	 * from xxl.applications.pipes.auctions.OpenAuction to  
	 * xxl.applications.pipes.auction.Bid.
	 * @return the function
	 */
	public final static Function GET_PRICE_FUNCTION() {
		return new Function(){
			public Object invoke(Object object) {	
				OpenAuction oa = (OpenAuction)(object);
			    Bidder b = (Bidder)oa.getBidder().get(0);
				Bid bid = new Bid();
				bid.setBid(b.getBid());
				bid.setItemID(oa.getId());
				bid.setBidderID(b.getPerson_ref().getPerson());
				bid.setTimestamp(b.getTime());				
				return bid;
			}
		};
	}	
	
	/**
	 * Returns a function, that transforms the content of a TimestampedObject
	 * from xxl.applications.pipes.auction.nexmark.mapping.OpenAuction to  
	 * xxl.applications.pipes.auction.Auction
	 * @return the function
	 */	
	public final static Function GET_OPEN_AUCTION_FUNCTION() {
		return new Function(){
			public Object invoke(Object object) {
				OpenAuction oa = (OpenAuction)((TemporalObject)object).getObject();
			    xxl.applications.pipes.auctions.OpenAuction auction = new xxl.applications.pipes.auctions.OpenAuction();
				auction.setAuctionID(oa.getId());
				auction.setItemID(oa.getItemref().getItem());
				auction.setPrivacy(oa.getPrivacy());
				if (auction.getPrivacy() == null)
					auction.setPrivacy("no");
				auction.setQuantity(oa.getQuantity());
				auction.setCategory(oa.getCategory());
				auction.setReserve(oa.getReserve());
				auction.setSeller(oa.getSeller().getPerson());
				auction.setType(oa.getType());
				auction.setTimestamp(((TemporalObject)object).getStart());
				// startprice muss separat behandelt werden
				((TemporalObject)object).setObject(auction);				
				return object;
			}
		};
	}
	
	/**
	 * Returns a function, that transforms the content of a TimestampedObject
	 * from xxl.applications.pipes.auction.nexmark.mapping.OpenAuction to  
	 * xxl.applications.pipes.auction.Auction
	 * @return the function
	 */	
	public final static Function GET_CLOSED_AUCTION_FUNCTION() {
		return new Function(){
			public Object invoke(Object o) {
			    OpenAuction oa = (OpenAuction)((TemporalObject)o).getObject();
			    ClosedAuction auction = new ClosedAuction();
				auction.setItemID(oa.getId());
				auction.setAuctionID(oa.getItemref().getItem());
				auction.setPrivacy(oa.getPrivacy());
				if (auction.getPrivacy() == null)
					auction.setPrivacy("no");
				auction.setQuantity(oa.getQuantity());
				auction.setCategory(oa.getCategory());
				auction.setReserve(oa.getReserve());
				auction.setSeller(oa.getSeller().getPerson());
				auction.setType(oa.getType());
				auction.setTimestamp(((TemporalObject)o).getStart());
				//buyer, sellprice müssen separat behandelt werden.
				((TemporalObject)o).setObject(auction);
				return o;
			}
		};
	}
	
	/**
	 * Reads the auction file "auction.xml", sorts it by the end timestamp and writes the 
	 * result in a file "closedauction.xml".
	 * @param path the path to the sourcefile auction.xml.
	 * @param mapFile a map for castor to map xml to java objects (NEXMark-mapping.xml).
	 */
	public static void makeClosedAuctionFile(final String path, final String mapFile) {
		Cursor cursor = getAuctionCursor(path+"auction.xml", mapFile);
		Comparator comp = new Comparator(){
			public int compare(Object o1, Object o2) {				
				return (int)(((OpenAuction)o1).getInterval().getEnd() - ((OpenAuction)o2).getInterval().getEnd());
            }		
		};
		DynamicHeap heap = new DynamicHeap(comp);
		heap.open();
		System.out.println("generating closedauctions.xml");
		System.out.print(" reading auction.xml ...");
		for (; cursor.hasNext(); heap.enqueue(cursor.next()));
		ArrayList list = new ArrayList();
		System.out.print("done\n sorting auction.xml and saving closedauction.xml...");
		Site site = new Site();
		OpenAuctions ao = new OpenAuctions();
		ArrayList list2 = new ArrayList();
		NexMarkConverter con = new NexMarkConverter(mapFile, path+"closedauction.xml");
		ao.setOpenAuction(list);
		list2.add(ao);
		site.setOpenAuctions(list2);
		while( !heap.isEmpty()){
			list.add(heap.dequeue());			
			con.append(site);
			list.clear();			
		}			
		heap.close();
		System.out.println("done");
	}
	
	/**
	 * A cursor, delivering tuples from the underlying nexmark xml file.
	 */
	protected Cursor fileInputCursor;
	
	/**
	 * The value determines the type of the stream - BID or Autionstream.
	 */
	protected int fileType;
	
	/**
	 * Determines the object that will be transfered into the query graph,
	 * the next time process() is called.
	 */
	protected Site nextObject;	
	
	/**
	 * This int is used to deliver the tuples at the specified time.
	 */
	protected int nextTime;
	
	/**
	 * This int is used to deliver the tuples at the specified time.
	 */
	protected int difference;

	/**
	* A factor to speed up or slow down the original tupel rate. for instance
	* 0,5 will increase the speed by 100%, 2 decrease the speed to 50% of the 
	* original rate.
	*/
	protected float factor;
	
	/**
	 * A flag, signing that the sleeping time has already been computed.
	 */
	protected boolean sleepTimeComputed;
	
	/**
	 * An index, which is only required for the auction stream. It is used
	 * to determine the correct tuple in the process method.
	 */
	protected int auctionsIndex;
	
	/**
	 * An index, which is only required for the auction stream. It is used
	 * to determine the correct tuple in the process method.
	 */
	protected int auctionIndex;

	
	/**
	 * A function, that can be used to transforms a TimestampedObject. every
	 * time before a tuple is passed to it's sinks the function is invoked on
	 * it. this feature can be used to tranform the complex nexmark objects
	 * to simpler objects that contain only the informations that are interessting.
	 * two standard functions have been added to this class.  
	 */
	protected Function function;
	
	/**
	 * Maps item ids to Price instances. Price contains startprice, sellprice and buyer.
	 * It is used to determine the start price, the sell price and the buyer with a Bid_Cursor.
	 * if an entry for an item is present, the Price instance is used, otherwise a random 
	 * start price is generated.    
	 */
	protected HashMap prices;
	
	/**
	 * This random instance is used to generate the first price, if no person
	 * send a bid to an article.  
	 */
	protected Random random;

	/**
	 * Constructs a new source, that will deliver TimestampedObject instances. The
	 * content of a such an object is an OpenAuction instance if no function has been
	 * specified or an arbitary object else.
	 * the creation of an interval (TimestampedObject) depends on the stream.
	 * BID: A bid has only a timestamp. therefore the timestamp is inserted as the start 
	 * of the interval and timestamp+1 is used as end. a temporal window is necessary to
	 * use the interval correctly. 
	 * Auction: An Auction has an intervall, which is used to create the interval directly.
	 * @param sourcePath the path to the xml files, generated by the modified NEXMark generator.
	 * it is assumed, that the source files have the following names: auction.xml, bid.xml and person.xml.
	 * @param mapFile a file, that is required to map xml to java objects with castor. use 
	 * xxl.applications.pipes.auctions.mapping.NEXMark-mapping.xml
	 * @param fileType the filetype. allowed are auction and bid stream.
	 * @param function a function that is invoked on a tupel before it is passed to its sinks. it
	 * is invoked on a TimestampObjekt and can be used to tranform the tuple.
	 * @param factor a factor to speed up or slow down the original tupel rate. for instance
	 * 0,5 will increase the speed by 100%, 2 decrease the speed to 50% of the 
	 * original rate.
	 * @param computePrices determines if the start and sell price of an item should be computed explicitly. 
	 */
	public NEXMarkGeneratorSource(String sourcePath, String mapFile, int fileType, Function function, float factor, boolean computePrices) {				
		if (fileType != OPEN_AUCTION_STREAM && fileType != CLOSED_AUCTION_STREAM && fileType != BID_STREAM)			
			throw new IllegalArgumentException("unknown filetype specified");				
		this.factor = factor;
		this.fileType = fileType;
		fileInputCursor = new FileInputCursor(new NexMarkConverter(mapFile), 
				new File(sourcePath+(fileType == BID_STREAM ? "bid.xml" : 
					(fileType == OPEN_AUCTION_STREAM ? "auction.xml" : "closedauction.xml"))));		
		nextObject = (Site) fileInputCursor.next();
		final NEXMarkGeneratorSource reference = this;		
		processor = new SourceProcessor(
			new Iterator() {
				NEXMarkGeneratorSource source = reference;
				public boolean hasNext(){
					return source.nextSleepTime() != -1;
				}
				public Object next() {					
					return new Long(source.nextSleepTime());
				}
				public void remove() {
					throw new UnsupportedOperationException(); 		
				}
			}
			, (Timer) TimerUtils.FACTORY_METHOD.invoke()
			,false
		);
		nextTime = this.fileType == BID_STREAM ? (int)((Bidder)((OpenAuction)((OpenAuctions)nextObject.getOpenAuctions().get(0)).getOpenAuction().get(0)).getBidder().get(0)).getTime()
			: (this.fileType == OPEN_AUCTION_STREAM ? (int)((OpenAuction)((OpenAuctions)nextObject.getOpenAuctions().get(0)).getOpenAuction().get(0)).getInterval().getStart() 
					:(int)((OpenAuction)((OpenAuctions)nextObject.getOpenAuctions().get(0)).getOpenAuction().get(0)).getInterval().getEnd()) ;		
		sleepTimeComputed = true;
		processor.registerSource(this);
		difference = 0;
		auctionsIndex = 0;
		auctionIndex = 0;
		this.function = function;
		prices = new HashMap();
		if (this.fileType != BID_STREAM && computePrices) 
			prices = loadMap(sourcePath, mapFile);		
		random = new Random();
	}
	
	/**
	 * Constructs a new source, that will deliver TimestampedObject instances. The
	 * content of a such an object is an OpenAuction instance if no function has been
	 * specified or an arbitary object else.
	 * the creation of an interval (TimestampedObject) depends on the stream.
	 * BID: A bid has only a timestamp. therefore the timestamp is inserted as the start 
	 * of the interval and timestamp+1 is used as end. a temporal window is necessary to
	 * use the interval correctly. 
	 * Auction: An Auction has an intervall, which is used to create the interval directly.
	 * @param sourcePath the path to the xml files, generated by the modified NEXMark generator.
	 * it is assumed, that the source files have the following names: auction.xml, bid.xml and person.xml.
	 * @param mapFile a file, that is required to map xml to java objects with castor. use 
	 * xxl.applications.pipes.auctions.mapping.NEXMark-mapping.xml
	 * @param fileType the filetype. allowed are auction and bid stream.
	 * @param function a function that is invoked on a tupel before it is passed to its sinks. it
	 * is invoked on a TimestampObjekt and can be used to tranform the tuple.
	 * @param factor a factor to speed up or slow down the original tupel rate. for instance
	 * 0,5 will increase the speed by 100%, 2 decrease the speed to 50% of the 
	 * original rate.
	 */
	public NEXMarkGeneratorSource(String sourcePath, String mapFile, int fileType, Function function, float factor) {
		this(sourcePath, mapFile, fileType, function, factor, false);
	}

	
	/**
	 * Constructs a new source, that will deliver TimestampedObject instances. The
	 * content of a such an object is an OpenAuction instance if no function has been
	 * specified or an arbitary object else.
	 * the creation of an interval (TimestampedObject) depends on the stream.
	 * BID: A bid has only a timestamp. therefore the timestamp is inserted as the start 
	 * of the interval and timestamp+1 is used as end. a temporal window is necessary to
	 * use the interval correctly. 
	 * Auction: An Auction has an intervall, which is used to create the interval directly.
	 * @param sourcePath the path to the xml files, generated by the modified NEXMark generator.
	 * it is assumed, that the source files have the following names: auction.xml, bid.xml and person.xml.
	 * @param mapFile a file, that is required to map xml to java objects with castor. use 
	 * xxl.applications.pipes.auctions.mapping.NEXMark-mapping.xml
	 * @param fileType the filetype. allowed are auction and bid stream.
	 * @param function a function that is invoked on a tupel before it is passed to its sinks. it
	 * is invoked on a TimestampObjekt and can be used to tranform the tuple.
	 */
	public NEXMarkGeneratorSource(String sourcePath, String mapFile, int fileType, Function function) {
		this(sourcePath, mapFile, fileType, function, 1);
	}
	
	/**
	 * Constructs a new source, that will deliver TimestampedObject instances,
	 * if a valid stream taype has been specified. 
	 * the creation of an interval (TimestampedObject) depends on the stream.
	 * BID: A bid has only a timestamp. therefore the timestamp is inserted as the start 
	 * of the interval and timestamp+1 is used as end. a temporal window is necessary to
	 * use the interval correctly. 
	 * Auction: An Auction has an intervall, which is used to create the interval directly.
	 * @param sourcePath the path to the xml files, generated by the modified NEXMark generator.
	 * it is assumed, that the source files have the following names: auction.xml, bid.xml and person.xml.
	 * @param mapFile a file, that is required to map xml to java objects with castor. use 
	 * xxl.applications.pipes.auctions.mapping.NEXMark-mapping.xml
	 * @param fileType the filetype. allowed are auction and bid stream.
	 * @param factor a factor to speed up or slow down the original tupel rate. for instance
	 * 0,5 will increase the speed by 100%, 2 decrease the speed to 50% of the 
	 * original rate.
	 */
	public NEXMarkGeneratorSource(String sourcePath, String mapFile, int fileType, float factor){
		this(sourcePath, mapFile, fileType, fileType==OPEN_AUCTION_STREAM ? GET_OPEN_AUCTION_FUNCTION(): 
			(fileType==CLOSED_AUCTION_STREAM ?  GET_CLOSED_AUCTION_FUNCTION() : GET_BID_FUNCTION()), factor);
	}

	/**
	 * Constructs a new source, that will deliver TimestampedObject instances,
	 * if a valid stream taype has been specified. 
	 * the creation of an interval (TimestampedObject) depends on the stream.
	 * BID: A bid has only a timestamp. therefore the timestamp is inserted as the start 
	 * of the interval and timestamp+1 is used as end. a temporal window is necessary to
	 * use the interval correctly. 
	 * Auction: An Auction has an intervall, which is used to create the interval directly.
	 * @param sourcePath the path to the xml files, generated by the modified NEXMark generator.
	 * it is assumed, that the source files have the following names: auction.xml, bid.xml and person.xml.
	 * @param mapFile a file, that is required to map xml to java objects with castor. use 
	 * xxl.applications.pipes.auctions.mapping.NEXMark-mapping.xml
	 * @param fileType the filetype. allowed are auction and bid stream.
	 */
	public NEXMarkGeneratorSource(String sourcePath, String mapFile, int fileType){
		this(sourcePath, mapFile, fileType, 1);
	}
	
	/**
	 * @return Object, an instances of TimestampedObject or an arbitary object, depending
	 * on the given function.
	 * @throws NoSuchElementException if all tuples have been delivered.
	 */
	public Object next() throws NoSuchElementException {		
		if (nextTime == -1)
			throw new NoSuchElementException();				
		sleepTimeComputed = false;		
		Object o = null;
		if (fileType == OPEN_AUCTION_STREAM || fileType == CLOSED_AUCTION_STREAM) {
			o = fileType == OPEN_AUCTION_STREAM ?
					new TemporalObject(((OpenAuctions)nextObject.getOpenAuctions().get(auctionsIndex)).getOpenAuction().get(auctionIndex)
						, new TimeInterval(((OpenAuction)((OpenAuctions)nextObject.getOpenAuctions().get(auctionsIndex)).getOpenAuction().get(auctionIndex)).getInterval().getStart()
						, TimeInterval.INFINITY)) :
					new TemporalObject(((OpenAuctions)nextObject.getOpenAuctions().get(auctionsIndex)).getOpenAuction().get(auctionIndex)
							, new TimeInterval(((OpenAuction)((OpenAuctions)nextObject.getOpenAuctions().get(auctionsIndex)).getOpenAuction().get(auctionIndex)).getInterval().getEnd()
							, TimeInterval.INFINITY));
			auctionIndex++;
		}
		else {
			if (((OpenAuctions)nextObject.getOpenAuctions().get(0)).getOpenAuction().size() == 1) {
				o = new TemporalObject(((OpenAuctions)nextObject.getOpenAuctions().get(0)).getOpenAuction().get(0)
					, new TimeInterval((int)((Bidder)((OpenAuction)((OpenAuctions)nextObject.getOpenAuctions().get(0)).getOpenAuction().get(0)).getBidder().get(0)).getTime()
					,TimeInterval.INFINITY));
			}
			else {
				for (int i=0; i< ((OpenAuctions)nextObject.getOpenAuctions().get(0)).getOpenAuction().size()-1; i++)
				{
					transfer( function==null ?
							new TemporalObject(((OpenAuctions)nextObject.getOpenAuctions().get(0)).getOpenAuction().get(i)
							, new TimeInterval((int)((Bidder)((OpenAuction)((OpenAuctions)nextObject.getOpenAuctions().get(0)).getOpenAuction().get(0)).getBidder().get(0)).getTime()
									,TimeInterval.INFINITY))
						:  	function.invoke( new TemporalObject(((OpenAuctions)nextObject.getOpenAuctions().get(0)).getOpenAuction().get(i)
								, new TimeInterval((int)((Bidder)((OpenAuction)((OpenAuctions)nextObject.getOpenAuctions().get(0)).getOpenAuction().get(0)).getBidder().get(0)).getTime()
										,TimeInterval.INFINITY))));
					
				}
				o = new TemporalObject(((OpenAuctions)nextObject.getOpenAuctions().get(0)).getOpenAuction().get(((OpenAuctions)nextObject.getOpenAuctions().get(0)).getOpenAuction().size()-1)
						, new TimeInterval((int)((Bidder)((OpenAuction)((OpenAuctions)nextObject.getOpenAuctions().get(0)).getOpenAuction().get(0)).getBidder().get(0)).getTime()
								,TimeInterval.INFINITY));				
			}
		}
		if (function == null)
			return o;
		o = function.invoke(o);
		if (fileType == OPEN_AUCTION_STREAM){
			if (prices.containsKey(new Long(((xxl.applications.pipes.auctions.OpenAuction)((TemporalObject)o).getObject()).getItemID())))
				((xxl.applications.pipes.auctions.OpenAuction)((TemporalObject)o).getObject()).setStartPrice(((Price)prices.get(new Long(((xxl.applications.pipes.auctions.OpenAuction)((TemporalObject)o).getObject()).getItemID()))).getStartPrice());
			else ((xxl.applications.pipes.auctions.OpenAuction)((TemporalObject)o).getObject()).setStartPrice(random.nextFloat()* random.nextInt(500));
		}
		else if (fileType == CLOSED_AUCTION_STREAM){
			if (prices.containsKey(new Long(((ClosedAuction)((TemporalObject)o).getObject()).getItemID()))){
				((ClosedAuction)((TemporalObject)o).getObject()).setSellPrice(((Price)prices.get(new Long(((ClosedAuction)((TemporalObject)o).getObject()).getItemID()))).getSellPrice());
				((ClosedAuction)((TemporalObject)o).getObject()).setBuyerId(((Price)prices.get(new Long(((ClosedAuction)((TemporalObject)o).getObject()).getItemID()))).getBuyer());
			}
			else {
				((ClosedAuction)((TemporalObject)o).getObject()).setBuyerId(ClosedAuction.NO_BUYER);
				((ClosedAuction)((TemporalObject)o).getObject()).setSellPrice(ClosedAuction.NOT_SOLD);
			}
		}
		return o;
	}
	
	/**
	 * computes the next sleeptime. the method is used by an simple iterator.
	 * @return the sleeptime. values greater or equal zero will be used for the sleeptime.
	 * -1 means that no more tuples can be delivered.
	 */
	protected int nextSleepTime() {		
		if (sleepTimeComputed)
			return (int)(factor * (nextTime - difference));  
		sleepTimeComputed = true;		
		if (fileType == OPEN_AUCTION_STREAM || fileType == CLOSED_AUCTION_STREAM) {
			if (((OpenAuctions)nextObject.getOpenAuctions().get(auctionsIndex)).getOpenAuction().size() > auctionIndex) {
				difference = nextTime;
				nextTime = fileType == OPEN_AUCTION_STREAM ? 
						(int)((OpenAuction)((OpenAuctions)nextObject.getOpenAuctions().get(auctionsIndex)).getOpenAuction().get(auctionIndex)).getInterval().getStart() :
						(int)((OpenAuction)((OpenAuctions)nextObject.getOpenAuctions().get(auctionsIndex)).getOpenAuction().get(auctionIndex)).getInterval().getEnd();				
				
			}
			else if (nextObject.getOpenAuctions().size() > auctionsIndex+1){  
				difference = nextTime;
				auctionIndex=0;
				auctionsIndex++;
				nextTime = fileType == OPEN_AUCTION_STREAM ? 
						(int)((OpenAuction)((OpenAuctions)nextObject.getOpenAuctions().get(auctionsIndex)).getOpenAuction().get(auctionIndex)).getInterval().getStart() :
						(int)((OpenAuction)((OpenAuctions)nextObject.getOpenAuctions().get(auctionsIndex)).getOpenAuction().get(auctionIndex)).getInterval().getEnd();				
			}
			else {
				do {
					if (! fileInputCursor.hasNext()) {
						nextTime=-1;
						return -1;					
					}					
					nextObject = (Site) fileInputCursor.next();
				}
				while (((OpenAuctions)nextObject.getOpenAuctions().get(0)).getOpenAuction().size() == 0);
				difference = nextTime;
				nextTime = fileType == OPEN_AUCTION_STREAM ?
					(int)((OpenAuction)((OpenAuctions)nextObject.getOpenAuctions().get(0)).getOpenAuction().get(0)).getInterval().getStart() :
					(int)((OpenAuction)((OpenAuctions)nextObject.getOpenAuctions().get(0)).getOpenAuction().get(0)).getInterval().getEnd();
				auctionIndex=0;
				auctionsIndex=0;
			}			
		}
		else {
			if (fileInputCursor.hasNext()){			
				do {
				nextObject = (Site) fileInputCursor.next();
				} while ( nextObject.getOpenAuctions().size() ==0 || ((OpenAuctions)nextObject.getOpenAuctions().get(0)).getOpenAuction().size() ==0);
				
				difference = nextTime;
				nextTime = (int)((Bidder)((OpenAuction)((OpenAuctions)nextObject.getOpenAuctions().get(0)).getOpenAuction().get(0)).getBidder().get(0)).getTime();			
				return (int)(factor * (nextTime - difference));				
			}						
			nextTime=-1;
			return -1;
		}
		return (int)(factor * (nextTime - difference));
	}

	/**
	 * @return Object
	 */
	public CompositeMetaData<Object, Object> getMetaData() {
		return super.getMetaData();		
	}
	
	/**
	 * tries to load the map. if the map does not exist, it is computed and saved. 
	 * @param path path to the nexmark data
	 * @param mapFile the castor mapping file
	 * @return the price map
	 */
	protected HashMap loadMap(String path, String mapFile) {
		File f = new File(path+"map.ser");
		HashMap hm = null;
		if (f.exists()) {
			try {				
				ObjectInputStream oos = new ObjectInputStream(new FileInputStream(f));
				hm = (HashMap)oos.readObject();
				return hm;
			} catch (Exception e) {
				e.printStackTrace();
			}
		}	
		if (hm == null) {			
			hm = new HashMap();
			Cursor c = getBidCursor(path+"bid.xml", mapFile);
			Bid bid = null;
			Price p = null;
			long time1 = System.currentTimeMillis();
			System.out.print("computing prices this takes about 15 - 90 seconds");
			while(c.hasNext()) {
				bid = (Bid)c.next();								
				if (hm.containsKey(new Long(bid.getItemID()))) {
					p = (Price)hm.get(new Long(bid.getItemID()));				
					if ( p.getSellPrice() < bid.getBid()) {
						p.setSellPrice(bid.getBid());
						p.setBuyer(bid.getBidderID());		
					}					
				}
				else {					
					hm.put(new Long(bid.getItemID()), new Price(bid.getBid(), bid.getBid(), bid.getBidderID()));					
				}
			}
			long time2 = System.currentTimeMillis();
			System.out.println(" ("+(time2-time1)+")");
			System.out.println("saving data...");
			try {
				ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(f));
				oos.writeObject(hm);
				System.out.println("done");
			} catch (Exception e) {
				System.out.println("failed");
			}			
		}
		return hm;
	}

	/**
	 * The main method contains some examples how to use an
	 * NEXMarkGeneratorSource. It can also be used to test the functionality
	 * of a NEXMarkGeneratorSource.
	 *
	 * @param args array of <tt>String</tt> arguments. It can be used to
	 *        submit parameters when the main method is called. The following
	 * 		  Arguments are required for a test <br>
	 *		arg0: sourceFile, the file from which NEXMarkGeneratorSource gets its input <br>
	 *		arg1: mapFile, a file mapping the xml input to java objects with castor. a
	 *			  mapping file has already been created (NEXMark-mapping.xml).<br>
	 * A lot of tests are in 'xxl.applications.pipes.Tests' (method: nexmarkTest).		
	 */
	public static void main(String[] args) {		
		if (args.length == 2) {
			//makeClosedAuctionFile(args[0], args[1]);
			//new VisualSink(new NEXMarkGeneratorSource(args[0], args[1], CLOSED_AUCTION_STREAM), true);
			//new VisualSink(new NEXMarkGeneratorSource(args[0], args[1], OPEN_AUCTION_STREAM), true);
			new VisualSink(new NEXMarkGeneratorSource(args[0], args[1], BID_STREAM), true);
		}
	}
	
}